
#line 3 "lex.yy.c"

#define  YY_INT_ALIGNED short int

/* A lexical scanner generated by flex */

#define FLEX_SCANNER
#define YY_FLEX_MAJOR_VERSION 2
#define YY_FLEX_MINOR_VERSION 5
#define YY_FLEX_SUBMINOR_VERSION 35
#if YY_FLEX_SUBMINOR_VERSION > 0
#define FLEX_BETA
#endif

/* First, we deal with  platform-specific or compiler-specific issues. */

/* begin standard C headers. */
#include <stdio.h>
#include <string.h>
#include <errno.h>
#include <stdlib.h>

/* end standard C headers. */

/* flex integer type definitions */

#ifndef FLEXINT_H
#define FLEXINT_H

/* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */

#if defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L

/* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,
 * if you want the limit (max/min) macros for int types. 
 */
#ifndef __STDC_LIMIT_MACROS
#define __STDC_LIMIT_MACROS 1
#endif

#include <inttypes.h>
typedef int8_t flex_int8_t;
typedef uint8_t flex_uint8_t;
typedef int16_t flex_int16_t;
typedef uint16_t flex_uint16_t;
typedef int32_t flex_int32_t;
typedef uint32_t flex_uint32_t;
#else
typedef signed char flex_int8_t;
typedef short int flex_int16_t;
typedef int flex_int32_t;
typedef unsigned char flex_uint8_t; 
typedef unsigned short int flex_uint16_t;
typedef unsigned int flex_uint32_t;

/* Limits of integral types. */
#ifndef INT8_MIN
#define INT8_MIN               (-128)
#endif
#ifndef INT16_MIN
#define INT16_MIN              (-32767-1)
#endif
#ifndef INT32_MIN
#define INT32_MIN              (-2147483647-1)
#endif
#ifndef INT8_MAX
#define INT8_MAX               (127)
#endif
#ifndef INT16_MAX
#define INT16_MAX              (32767)
#endif
#ifndef INT32_MAX
#define INT32_MAX              (2147483647)
#endif
#ifndef UINT8_MAX
#define UINT8_MAX              (255U)
#endif
#ifndef UINT16_MAX
#define UINT16_MAX             (65535U)
#endif
#ifndef UINT32_MAX
#define UINT32_MAX             (4294967295U)
#endif

#endif /* ! C99 */

#endif /* ! FLEXINT_H */

#ifdef __cplusplus

/* The "const" storage-class-modifier is valid. */
#define YY_USE_CONST

#else	/* ! __cplusplus */

/* C99 requires __STDC__ to be defined as 1. */
#if defined (__STDC__)

#define YY_USE_CONST

#endif	/* defined (__STDC__) */
#endif	/* ! __cplusplus */

#ifdef YY_USE_CONST
#define yyconst const
#else
#define yyconst
#endif

/* Returned upon end-of-file. */
#define YY_NULL 0

/* Promotes a possibly negative, possibly signed char to an unsigned
 * integer for use as an array index.  If the signed char is negative,
 * we want to instead treat it as an 8-bit unsigned char, hence the
 * double cast.
 */
#define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)

/* Enter a start condition.  This macro really ought to take a parameter,
 * but we do it the disgusting crufty way forced on us by the ()-less
 * definition of BEGIN.
 */
#define BEGIN (yy_start) = 1 + 2 *

/* Translate the current start state into a value that can be later handed
 * to BEGIN to return to the state.  The YYSTATE alias is for lex
 * compatibility.
 */
#define YY_START (((yy_start) - 1) / 2)
#define YYSTATE YY_START

/* Action number for EOF rule of a given start state. */
#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)

/* Special action meaning "start processing a new file". */
#define YY_NEW_FILE yyrestart(yyin  )

#define YY_END_OF_BUFFER_CHAR 0

/* Size of default input buffer. */
#ifndef YY_BUF_SIZE
#ifdef __ia64__
/* On IA-64, the buffer size is 16k, not 8k.
 * Moreover, YY_BUF_SIZE is 2*YY_READ_BUF_SIZE in the general case.
 * Ditto for the __ia64__ case accordingly.
 */
#define YY_BUF_SIZE 32768
#else
#define YY_BUF_SIZE 16384
#endif /* __ia64__ */
#endif

/* The state buf must be large enough to hold one state per character in the main buffer.
 */
#define YY_STATE_BUF_SIZE   ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))

#ifndef YY_TYPEDEF_YY_BUFFER_STATE
#define YY_TYPEDEF_YY_BUFFER_STATE
typedef struct yy_buffer_state *YY_BUFFER_STATE;
#endif

extern int yyleng;

extern FILE *yyin, *yyout;

#define EOB_ACT_CONTINUE_SCAN 0
#define EOB_ACT_END_OF_FILE 1
#define EOB_ACT_LAST_MATCH 2

    #define YY_LESS_LINENO(n)
    
/* Return all but the first "n" matched characters back to the input stream. */
#define yyless(n) \
	do \
		{ \
		/* Undo effects of setting up yytext. */ \
        int yyless_macro_arg = (n); \
        YY_LESS_LINENO(yyless_macro_arg);\
		*yy_cp = (yy_hold_char); \
		YY_RESTORE_YY_MORE_OFFSET \
		(yy_c_buf_p) = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ; \
		YY_DO_BEFORE_ACTION; /* set up yytext again */ \
		} \
	while ( 0 )

#define unput(c) yyunput( c, (yytext_ptr)  )

#ifndef YY_TYPEDEF_YY_SIZE_T
#define YY_TYPEDEF_YY_SIZE_T
typedef size_t yy_size_t;
#endif

#ifndef YY_STRUCT_YY_BUFFER_STATE
#define YY_STRUCT_YY_BUFFER_STATE
struct yy_buffer_state
	{
	FILE *yy_input_file;

	char *yy_ch_buf;		/* input buffer */
	char *yy_buf_pos;		/* current position in input buffer */

	/* Size of input buffer in bytes, not including room for EOB
	 * characters.
	 */
	yy_size_t yy_buf_size;

	/* Number of characters read into yy_ch_buf, not including EOB
	 * characters.
	 */
	int yy_n_chars;

	/* Whether we "own" the buffer - i.e., we know we created it,
	 * and can realloc() it to grow it, and should free() it to
	 * delete it.
	 */
	int yy_is_our_buffer;

	/* Whether this is an "interactive" input source; if so, and
	 * if we're using stdio for input, then we want to use getc()
	 * instead of fread(), to make sure we stop fetching input after
	 * each newline.
	 */
	int yy_is_interactive;

	/* Whether we're considered to be at the beginning of a line.
	 * If so, '^' rules will be active on the next match, otherwise
	 * not.
	 */
	int yy_at_bol;

    int yy_bs_lineno; /**< The line count. */
    int yy_bs_column; /**< The column count. */
    
	/* Whether to try to fill the input buffer when we reach the
	 * end of it.
	 */
	int yy_fill_buffer;

	int yy_buffer_status;

#define YY_BUFFER_NEW 0
#define YY_BUFFER_NORMAL 1
	/* When an EOF's been seen but there's still some text to process
	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
	 * shouldn't try reading from the input source any more.  We might
	 * still have a bunch of tokens to match, though, because of
	 * possible backing-up.
	 *
	 * When we actually see the EOF, we change the status to "new"
	 * (via yyrestart()), so that the user can continue scanning by
	 * just pointing yyin at a new input file.
	 */
#define YY_BUFFER_EOF_PENDING 2

	};
#endif /* !YY_STRUCT_YY_BUFFER_STATE */

/* Stack of input buffers. */
static size_t yy_buffer_stack_top = 0; /**< index of top of stack. */
static size_t yy_buffer_stack_max = 0; /**< capacity of stack. */
static YY_BUFFER_STATE * yy_buffer_stack = 0; /**< Stack as an array. */

/* We provide macros for accessing buffer states in case in the
 * future we want to put the buffer states in a more general
 * "scanner state".
 *
 * Returns the top of the stack, or NULL.
 */
#define YY_CURRENT_BUFFER ( (yy_buffer_stack) \
                          ? (yy_buffer_stack)[(yy_buffer_stack_top)] \
                          : NULL)

/* Same as previous macro, but useful when we know that the buffer stack is not
 * NULL or when we need an lvalue. For internal use only.
 */
#define YY_CURRENT_BUFFER_LVALUE (yy_buffer_stack)[(yy_buffer_stack_top)]

/* yy_hold_char holds the character lost when yytext is formed. */
static char yy_hold_char;
static int yy_n_chars;		/* number of characters read into yy_ch_buf */
int yyleng;

/* Points to current character in buffer. */
static char *yy_c_buf_p = (char *) 0;
static int yy_init = 0;		/* whether we need to initialize */
static int yy_start = 0;	/* start state number */

/* Flag which is used to allow yywrap()'s to do buffer switches
 * instead of setting up a fresh yyin.  A bit of a hack ...
 */
static int yy_did_buffer_switch_on_eof;

void yyrestart (FILE *input_file  );
void yy_switch_to_buffer (YY_BUFFER_STATE new_buffer  );
YY_BUFFER_STATE yy_create_buffer (FILE *file,int size  );
void yy_delete_buffer (YY_BUFFER_STATE b  );
void yy_flush_buffer (YY_BUFFER_STATE b  );
void yypush_buffer_state (YY_BUFFER_STATE new_buffer  );
void yypop_buffer_state (void );

static void yyensure_buffer_stack (void );
static void yy_load_buffer_state (void );
static void yy_init_buffer (YY_BUFFER_STATE b,FILE *file  );

#define YY_FLUSH_BUFFER yy_flush_buffer(YY_CURRENT_BUFFER )

YY_BUFFER_STATE yy_scan_buffer (char *base,yy_size_t size  );
YY_BUFFER_STATE yy_scan_string (yyconst char *yy_str  );
YY_BUFFER_STATE yy_scan_bytes (yyconst char *bytes,int len  );

void *yyalloc (yy_size_t  );
void *yyrealloc (void *,yy_size_t  );
void yyfree (void *  );

#define yy_new_buffer yy_create_buffer

#define yy_set_interactive(is_interactive) \
	{ \
	if ( ! YY_CURRENT_BUFFER ){ \
        yyensure_buffer_stack (); \
		YY_CURRENT_BUFFER_LVALUE =    \
            yy_create_buffer(yyin,YY_BUF_SIZE ); \
	} \
	YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \
	}

#define yy_set_bol(at_bol) \
	{ \
	if ( ! YY_CURRENT_BUFFER ){\
        yyensure_buffer_stack (); \
		YY_CURRENT_BUFFER_LVALUE =    \
            yy_create_buffer(yyin,YY_BUF_SIZE ); \
	} \
	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol; \
	}

#define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)

/* Begin user sect3 */

typedef unsigned char YY_CHAR;

FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;

typedef int yy_state_type;

extern int yylineno;

int yylineno = 1;

extern char *yytext;
#define yytext_ptr yytext

static yy_state_type yy_get_previous_state (void );
static yy_state_type yy_try_NUL_trans (yy_state_type current_state  );
static int yy_get_next_buffer (void );
static void yy_fatal_error (yyconst char msg[]  );

/* Done after the current pattern has been matched and before the
 * corresponding action - sets up yytext.
 */
#define YY_DO_BEFORE_ACTION \
	(yytext_ptr) = yy_bp; \
	yyleng = (size_t) (yy_cp - yy_bp); \
	(yy_hold_char) = *yy_cp; \
	*yy_cp = '\0'; \
	(yy_c_buf_p) = yy_cp;

#define YY_NUM_RULES 44
#define YY_END_OF_BUFFER 45
/* This struct is not used in this scanner,
   but its presence is necessary. */
struct yy_trans_info
	{
	flex_int32_t yy_verify;
	flex_int32_t yy_nxt;
	};
static yyconst flex_int16_t yy_accept[198] =
    {   0,
        8,    8,   45,   43,   11,   12,   43,   43,   34,   17,
       19,    3,   20,    1,   23,    3,    3,    3,    8,    8,
        8,    8,    8,    8,    8,    8,    8,    8,    8,    8,
        8,    8,    8,    8,    8,   36,    0,    0,    5,    0,
       26,   35,    2,    1,    8,   29,    6,    4,    7,    8,
        8,    8,    8,    8,    8,    8,    8,    8,    8,    8,
        8,    8,    8,    8,    8,    8,    8,    8,   37,    0,
        2,    8,    8,    8,    8,    8,    8,    8,    8,    8,
        8,    8,    8,    8,    8,    8,    8,    8,    8,    8,
        8,    8,    0,    8,    8,    8,    8,    8,    8,    8,

        8,    8,    8,    8,   18,    8,    8,    8,    8,    8,
        8,    8,    8,    8,    8,    0,    8,    8,    8,   38,
        8,   21,    8,    8,   25,    8,   39,    8,    8,    8,
       41,    8,   28,    8,    8,    8,    8,    8,    8,    8,
        8,    8,    0,   40,    8,    8,    8,    8,    8,    8,
        8,   16,    8,    8,    8,    8,   15,    8,    8,    8,
        8,    0,   14,    8,   13,    8,   24,    8,    8,    8,
       42,    8,   27,    8,    8,    8,   33,    8,   30,    8,
       10,    8,    0,    8,    8,    8,    0,   32,    8,    0,
       31,    8,    9,    0,    0,   22,    0

    } ;

static yyconst flex_int32_t yy_ec[256] =
    {   0,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    2,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    3,    4,    5,    1,    1,    1,    6,    1,    7,
        8,    9,   10,   11,   12,   13,   14,   15,   15,   15,
       15,   15,   15,   15,   15,   15,   15,    1,   16,   17,
       18,   19,    1,    1,   20,   21,   22,   23,   24,   25,
       26,   27,   28,   29,   30,   31,   32,   33,   34,   35,
       29,   36,   37,   38,   39,   40,   41,   42,   43,   29,
        1,    1,    1,    1,   44,    1,   45,   29,   46,   29,

       47,   29,   29,   29,   29,   48,   29,   49,   50,   51,
       52,   53,   29,   54,   55,   56,   29,   29,   29,   29,
       29,   29,    1,   57,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,

        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1
    } ;

static yyconst flex_int32_t yy_meta[58] =
    {   0,
        1,    2,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    3,    1,    3,    1,    1,    1,    1,    3,
        3,    3,    3,    3,    3,    3,    3,    3,    3,    3,
        3,    3,    3,    3,    3,    3,    3,    3,    3,    3,
        3,    3,    3,    3,    3,    3,    3,    3,    3,    3,
        3,    3,    3,    3,    3,    3,    1
    } ;

static yyconst flex_int16_t yy_base[200] =
    {   0,
        0,    0,  376,  383,  383,   55,  357,  369,  367,  383,
      383,  383,  383,   46,  383,   48,  354,  353,  356,   49,
       50,   51,   52,   54,   55,   56,   57,   62,   58,   59,
       64,   78,   60,   63,   66,  311,   92,  334,  383,  361,
      383,  383,  350,   83,  351,  383,  383,  383,  383,   84,
       87,   86,   88,   89,   90,   91,   93,   94,   95,   96,
       99,  109,  106,  111,  113,  118,  123,  119,  383,  325,
      347,  125,  126,  127,  128,  131,  130,  135,  132,  139,
      136,  137,  154,  140,  142,  159,  145,  163,  146,  147,
      151,  162,  337,  164,  165,  167,  170,  186,  174,  187,

      189,  184,  180,  195,  383,  188,  203,  200,  201,  204,
      194,  206,  207,  209,  212,  334,  223,  214,  218,  383,
      220,  383,  216,  222,  383,  224,  383,  221,  228,  233,
      383,  230,  383,  236,  252,  253,  231,  254,  266,  234,
      235,  238,  327,  383,  240,  270,  272,  273,  259,  257,
      265,  383,  268,  290,  293,  274,  383,  271,  276,  299,
      301,  311,  383,  292,  383,  295,  383,  278,  310,  302,
      383,  296,  383,  304,  309,  317,  383,  305,  383,  308,
      383,  312,  324,  321,  323,  327,  329,  383,  325,  322,
      383,  326,  383,  333,  300,  383,  383,  379,  339

    } ;

static yyconst flex_int16_t yy_def[200] =
    {   0,
      197,    1,  197,  197,  197,  197,  197,  198,  197,  197,
      197,  197,  197,  199,  197,  197,  197,  197,  199,  199,
      199,  199,  199,  199,  199,  199,  199,  199,  199,  199,
      199,  199,  199,  199,  199,  197,  197,  197,  197,  198,
      197,  197,  197,  199,  199,  197,  197,  197,  197,  199,
      199,  199,  199,  199,  199,  199,  199,  199,  199,  199,
      199,  199,  199,  199,  199,  199,  199,  199,  197,  197,
      197,  199,  199,  199,  199,  199,  199,  199,  199,  199,
      199,  199,  199,  199,  199,  199,  199,  199,  199,  199,
      199,  199,  197,  199,  199,  199,  199,  199,  199,  199,

      199,  199,  199,  199,  197,  199,  199,  199,  199,  199,
      199,  199,  199,  199,  199,  197,  199,  199,  199,  197,
      199,  197,  199,  199,  197,  199,  197,  199,  199,  199,
      197,  199,  197,  199,  199,  199,  199,  199,  199,  199,
      199,  199,  197,  197,  199,  199,  199,  199,  199,  199,
      199,  197,  199,  199,  199,  199,  197,  199,  199,  199,
      199,  197,  197,  199,  197,  199,  197,  199,  199,  199,
      197,  199,  197,  199,  199,  199,  197,  199,  197,  199,
      197,  199,  197,  199,  199,  199,  197,  197,  199,  197,
      197,  199,  197,  197,  197,  197,    0,  197,  197

    } ;

static yyconst flex_int16_t yy_nxt[441] =
    {   0,
        4,    5,    6,    7,    8,    9,   10,   11,   12,   12,
       13,   12,    4,   12,   14,   15,   16,   17,   18,   19,
       19,   20,   21,   22,   23,   19,   19,   24,   19,   19,
       19,   19,   19,   25,   26,   27,   28,   29,   30,   31,
       32,   19,   19,   19,   19,   19,   19,   19,   19,   19,
       19,   19,   33,   34,   35,   19,   36,   37,   43,   46,
       44,  197,  197,  197,  197,   47,  197,  197,  197,  197,
      197,  197,  197,   52,  197,  197,  197,   62,  197,   50,
       58,   59,   38,   64,   51,   60,   55,   54,   61,   56,
      197,   57,   53,   63,   37,   43,  197,   44,  197,  197,

      197,  197,  197,  197,   65,  197,  197,  197,  197,   67,
       73,  197,   68,   66,   79,   75,   74,   72,  197,   38,
       80,  197,   76,  197,   81,  197,   77,   78,   86,   85,
      197,  197,   84,   83,   82,  197,   89,  197,  197,  197,
      197,   87,  197,  197,  197,   95,   88,  197,  197,  197,
       96,  197,  197,   99,  197,  103,  105,  197,  197,  197,
      104,   94,   98,  197,  101,   97,  197,   92,  100,   90,
      102,  197,  108,   91,  197,  197,  197,  197,  109,  197,
      107,  112,  197,  110,  111,  120,  197,  117,  122,  125,
      106,  127,  197,  121,  113,  114,  197,  131,  197,  197,

      197,  197,  118,  129,  119,  133,  197,  197,  115,  124,
      123,   60,  197,  197,  126,  197,  197,  130,  197,  197,
      138,  197,  128,  135,  197,  144,  197,  137,  197,  139,
      197,  132,  197,  197,  197,  197,  197,  146,  136,  134,
      197,  147,  197,  197,  145,  197,  197,  197,  197,   59,
      197,   54,  197,  140,  152,   56,  149,  142,  141,  148,
      151,   53,   61,  150,  197,  197,  197,  155,  157,  197,
       50,  197,  163,  156,  165,  167,  154,  197,  197,  159,
      197,  160,  197,  197,  197,  197,  197,   62,  197,  153,
      197,  164,  171,  161,  166,  173,   78,   65,  170,  169,

      168,  177,  197,  179,  197,  197,  158,  197,  197,  175,
      182,  197,  183,  197,  197,  187,  197,  197,   52,  188,
      197,  197,  197,  186,  197,  191,  183,   51,  172,  197,
       63,  176,  174,  197,  185,  197,  193,  197,  197,  197,
      193,   45,  196,  194,  184,  195,  181,  194,   77,   58,
      162,   67,  178,  190,   68,  180,   57,   87,  192,  143,
      116,   71,   93,  197,   71,   41,   70,   69,  197,  189,
       49,   48,   42,   41,   39,  197,  197,  197,   66,   40,
      197,   40,    3,  197,  197,  197,  197,  197,  197,  197,
      197,  197,  197,  197,  197,  197,  197,  197,  197,  197,

      197,  197,  197,  197,  197,  197,  197,  197,  197,  197,
      197,  197,  197,  197,  197,  197,  197,  197,  197,  197,
      197,  197,  197,  197,  197,  197,  197,  197,  197,  197,
      197,  197,  197,  197,  197,  197,  197,  197,  197,  197
    } ;

static yyconst flex_int16_t yy_chk[441] =
    {   0,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    6,   14,   16,
       14,   20,   21,   22,   23,   16,   24,   25,   26,   27,
       29,   30,   33,   21,   28,   34,   31,   29,   35,   20,
       27,   28,    6,   31,   20,   28,   24,   23,   28,   25,
       32,   26,   22,   30,   37,   44,   50,   44,   52,   51,

       53,   54,   55,   56,   32,   57,   58,   59,   60,   34,
       51,   61,   35,   33,   56,   53,   52,   50,   63,   37,
       57,   62,   54,   64,   58,   65,   55,   55,   63,   62,
       66,   68,   61,   60,   59,   67,   65,   72,   73,   74,
       75,   64,   77,   76,   79,   73,   64,   78,   81,   82,
       74,   80,   84,   77,   85,   81,   83,   87,   89,   90,
       82,   72,   76,   91,   79,   75,   83,   68,   78,   66,
       80,   86,   85,   67,   92,   88,   94,   95,   86,   96,
       84,   89,   97,   87,   88,   97,   99,   94,   98,  100,
       83,  101,  103,   97,   90,   91,  102,  104,   98,  100,

      106,  101,   95,  102,   96,  107,  111,  104,   92,   99,
       98,  106,  108,  109,  100,  107,  110,  103,  112,  113,
      111,  114,  101,  108,  115,  117,  118,  110,  123,  112,
      119,  104,  121,  128,  124,  117,  126,  118,  109,  107,
      129,  119,  132,  137,  117,  130,  140,  141,  134,  132,
      142,  123,  145,  113,  135,  128,  126,  115,  114,  124,
      130,  121,  134,  129,  135,  136,  138,  137,  139,  150,
      145,  149,  146,  138,  147,  148,  136,  151,  139,  140,
      153,  141,  146,  158,  147,  148,  156,  153,  159,  135,
      168,  146,  154,  142,  147,  155,  149,  158,  151,  150,

      148,  160,  154,  161,  164,  155,  139,  166,  172,  156,
      168,  160,  169,  161,  170,  175,  174,  178,  166,  176,
      180,  175,  169,  174,  182,  185,  183,  164,  154,  176,
      172,  159,  155,  184,  170,  185,  187,  189,  192,  186,
      194,  199,  195,  187,  169,  190,  162,  194,  182,  192,
      143,  178,  160,  183,  180,  161,  184,  186,  185,  116,
       93,   71,   70,   45,   43,   40,   38,   36,   19,  176,
       18,   17,    9,    8,    7,    3,    0,    0,  189,  198,
        0,  198,  197,  197,  197,  197,  197,  197,  197,  197,
      197,  197,  197,  197,  197,  197,  197,  197,  197,  197,

      197,  197,  197,  197,  197,  197,  197,  197,  197,  197,
      197,  197,  197,  197,  197,  197,  197,  197,  197,  197,
      197,  197,  197,  197,  197,  197,  197,  197,  197,  197,
      197,  197,  197,  197,  197,  197,  197,  197,  197,  197
    } ;

static yy_state_type yy_last_accepting_state;
static char *yy_last_accepting_cpos;

extern int yy_flex_debug;
int yy_flex_debug = 0;

/* The intent behind this definition is that it'll catch
 * any uses of REJECT which flex missed.
 */
#define REJECT reject_used_but_not_detected
#define yymore() yymore_used_but_not_detected
#define YY_MORE_ADJ 0
#define YY_RESTORE_YY_MORE_OFFSET
char *yytext;
#line 1 "scanner.l"
/* 
    COMPILE COMMANDS:
    flex scanner.l
    g++ lex.yy.c -lfl
    ./a.out
*/
#line 8 "scanner.l"
#include <iostream>
#include "Token.h"
#include <string.h>
#include <stdlib.h>
#include <stack>
#include <vector>
#include <fstream>
#include <sstream>
#include <stdlib.h>
#include "Parser.h"
 
using namespace std;

stack<Token> tokens;
int errors= 0;
#line 642 "lex.yy.c"

#define INITIAL 0

#ifndef YY_NO_UNISTD_H
/* Special case for "unistd.h", since it is non-ANSI. We include it way
 * down here because we want the user's section 1 to have been scanned first.
 * The user has a chance to override it with an option.
 */
#include <unistd.h>
#endif

#ifndef YY_EXTRA_TYPE
#define YY_EXTRA_TYPE void *
#endif

static int yy_init_globals (void );

/* Accessor methods to globals.
   These are made visible to non-reentrant scanners for convenience. */

int yylex_destroy (void );

int yyget_debug (void );

void yyset_debug (int debug_flag  );

YY_EXTRA_TYPE yyget_extra (void );

void yyset_extra (YY_EXTRA_TYPE user_defined  );

FILE *yyget_in (void );

void yyset_in  (FILE * in_str  );

FILE *yyget_out (void );

void yyset_out  (FILE * out_str  );

int yyget_leng (void );

char *yyget_text (void );

int yyget_lineno (void );

void yyset_lineno (int line_number  );

/* Macros after this point can all be overridden by user definitions in
 * section 1.
 */

#ifndef YY_SKIP_YYWRAP
#ifdef __cplusplus
extern "C" int yywrap (void );
#else
extern int yywrap (void );
#endif
#endif

    static void yyunput (int c,char *buf_ptr  );
    
#ifndef yytext_ptr
static void yy_flex_strncpy (char *,yyconst char *,int );
#endif

#ifdef YY_NEED_STRLEN
static int yy_flex_strlen (yyconst char * );
#endif

#ifndef YY_NO_INPUT

#ifdef __cplusplus
static int yyinput (void );
#else
static int input (void );
#endif

#endif

/* Amount of stuff to slurp up with each read. */
#ifndef YY_READ_BUF_SIZE
#ifdef __ia64__
/* On IA-64, the buffer size is 16k, not 8k */
#define YY_READ_BUF_SIZE 16384
#else
#define YY_READ_BUF_SIZE 8192
#endif /* __ia64__ */
#endif

/* Copy whatever the last rule matched to the standard output. */
#ifndef ECHO
/* This used to be an fputs(), but since the string might contain NUL's,
 * we now use fwrite().
 */
#define ECHO do { if (fwrite( yytext, yyleng, 1, yyout )) {} } while (0)
#endif

/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
 * is returned in "result".
 */
#ifndef YY_INPUT
#define YY_INPUT(buf,result,max_size) \
	if ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \
		{ \
		int c = '*'; \
		size_t n; \
		for ( n = 0; n < max_size && \
			     (c = getc( yyin )) != EOF && c != '\n'; ++n ) \
			buf[n] = (char) c; \
		if ( c == '\n' ) \
			buf[n++] = (char) c; \
		if ( c == EOF && ferror( yyin ) ) \
			YY_FATAL_ERROR( "input in flex scanner failed" ); \
		result = n; \
		} \
	else \
		{ \
		errno=0; \
		while ( (result = fread(buf, 1, max_size, yyin))==0 && ferror(yyin)) \
			{ \
			if( errno != EINTR) \
				{ \
				YY_FATAL_ERROR( "input in flex scanner failed" ); \
				break; \
				} \
			errno=0; \
			clearerr(yyin); \
			} \
		}\
\

#endif

/* No semi-colon after return; correct usage is to write "yyterminate();" -
 * we don't want an extra ';' after the "return" because that will cause
 * some compilers to complain about unreachable statements.
 */
#ifndef yyterminate
#define yyterminate() return YY_NULL
#endif

/* Number of entries by which start-condition stack grows. */
#ifndef YY_START_STACK_INCR
#define YY_START_STACK_INCR 25
#endif

/* Report a fatal error. */
#ifndef YY_FATAL_ERROR
#define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
#endif

/* end tables serialization structures and prototypes */

/* Default declaration of generated scanner - a define so the user can
 * easily add parameters.
 */
#ifndef YY_DECL
#define YY_DECL_IS_OURS 1

extern int yylex (void);

#define YY_DECL int yylex (void)
#endif /* !YY_DECL */

/* Code executed at the beginning of each rule, after yytext and yyleng
 * have been set up.
 */
#ifndef YY_USER_ACTION
#define YY_USER_ACTION
#endif

/* Code executed at the end of each rule. */
#ifndef YY_BREAK
#define YY_BREAK break;
#endif

#define YY_RULE_SETUP \
	YY_USER_ACTION

/** The main scanner function which does all the work.
 */
YY_DECL
{
	register yy_state_type yy_current_state;
	register char *yy_cp, *yy_bp;
	register int yy_act;
    
#line 65 "scanner.l"

#line 831 "lex.yy.c"

	if ( !(yy_init) )
		{
		(yy_init) = 1;

#ifdef YY_USER_INIT
		YY_USER_INIT;
#endif

		if ( ! (yy_start) )
			(yy_start) = 1;	/* first start state */

		if ( ! yyin )
			yyin = stdin;

		if ( ! yyout )
			yyout = stdout;

		if ( ! YY_CURRENT_BUFFER ) {
			yyensure_buffer_stack ();
			YY_CURRENT_BUFFER_LVALUE =
				yy_create_buffer(yyin,YY_BUF_SIZE );
		}

		yy_load_buffer_state( );
		}

	while ( 1 )		/* loops until end-of-file is reached */
		{
		yy_cp = (yy_c_buf_p);

		/* Support of yytext. */
		*yy_cp = (yy_hold_char);

		/* yy_bp points to the position in yy_ch_buf of the start of
		 * the current run.
		 */
		yy_bp = yy_cp;

		yy_current_state = (yy_start);
yy_match:
		do
			{
			register YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];
			if ( yy_accept[yy_current_state] )
				{
				(yy_last_accepting_state) = yy_current_state;
				(yy_last_accepting_cpos) = yy_cp;
				}
			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
				{
				yy_current_state = (int) yy_def[yy_current_state];
				if ( yy_current_state >= 198 )
					yy_c = yy_meta[(unsigned int) yy_c];
				}
			yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
			++yy_cp;
			}
		while ( yy_base[yy_current_state] != 383 );

yy_find_action:
		yy_act = yy_accept[yy_current_state];
		if ( yy_act == 0 )
			{ /* have to back up */
			yy_cp = (yy_last_accepting_cpos);
			yy_current_state = (yy_last_accepting_state);
			yy_act = yy_accept[yy_current_state];
			}

		YY_DO_BEFORE_ACTION;

do_action:	/* This label is used only to access EOF actions. */

		switch ( yy_act )
	{ /* beginning of action switch */
			case 0: /* must back up */
			/* undo the effects of YY_DO_BEFORE_ACTION */
			*yy_cp = (yy_hold_char);
			yy_cp = (yy_last_accepting_cpos);
			yy_current_state = (yy_last_accepting_state);
			goto yy_find_action;

case 1:
YY_RULE_SETUP
#line 66 "scanner.l"
{  
            // Identifies and passes integers to stack 
            //cout<<"Integer VALUE:"<<yytext<<endl;
            Token temp(T_INTVALUE,atoi(yytext));
            tokens.push(temp);
        }
	YY_BREAK
case 2:
YY_RULE_SETUP
#line 72 "scanner.l"
{
            // Identifies and passes Doubles to stack 
            //cout<<"Double VALUE:"<<yytext<<endl;
            Token temp(T_DOUBLEVALUE,atof(yytext));
            tokens.push(temp);
}
	YY_BREAK
case 3:
YY_RULE_SETUP
#line 78 "scanner.l"
{ 
            // Check what operator the string is, pass token with type 
            // corresponding to that operator
            //cout<<"OPERATOR:"<<yytext<<endl;
            string s(yytext); 
            switch(yytext[0]){
                case '+':{  
                    Token temp(T_PLUS,s);
                    tokens.push(temp);
                    break;
                }
                case '-':{
                    Token temp(T_MINUS,s);
                    tokens.push(temp);
                    break;
                }
                case '*':{
                    Token temp(T_MULTIPLY,s);
                    tokens.push(temp);
                    break;
                }
                case '/':{
                    Token temp(T_DIVIDE,s);
                    tokens.push(temp);
                    break;
                }
                case '=':{
                    Token temp(T_EQUAL,s);
                    tokens.push(temp);
                    break;
                }
                case '<':{
                    Token temp(T_LESS,s);
                    tokens.push(temp);
                    break;
                }
                 case '>':{
                    Token temp(T_GREATER,s);
                    tokens.push(temp);
                    break;
                }
                default:{
                    break;
                }

            }
}
	YY_BREAK
case 4:
YY_RULE_SETUP
#line 125 "scanner.l"
{             
            //cout<<"TWO EQUALS SIGN"<<endl;
            string s(yytext);
            Token temp(T_TWOEQUALS,s);
            tokens.push(temp);

}
	YY_BREAK
case 5:
YY_RULE_SETUP
#line 132 "scanner.l"
{             
            //cout<<"NOT EQUALS SIGN"<<endl;
            string s(yytext);   
            Token temp(T_NOTEQUAL,s);
            tokens.push(temp);

}
	YY_BREAK
case 6:
YY_RULE_SETUP
#line 139 "scanner.l"
{             
            //cout<<"LESS EQUALS SIGN"<<endl;
            string s(yytext); 
            Token temp(T_LESSEQUAL,s);
            tokens.push(temp);

}
	YY_BREAK
case 7:
YY_RULE_SETUP
#line 146 "scanner.l"
{             
            //cout<<"LESS EQUALS SIGN"<<endl;
            string s(yytext); 
            Token temp(T_GREATEREQUAL,s);
            tokens.push(temp);

}
	YY_BREAK
case 8:
YY_RULE_SETUP
#line 153 "scanner.l"
{
        // push token with corresponding identifier type to stack
        //cout<<"An IDENTIFIER: " <<yytext<<endl;
            string s(yytext);
            Token temp(T_IDENTIFIER,s);
            tokens.push(temp);
}
	YY_BREAK
case 9:
YY_RULE_SETUP
#line 160 "scanner.l"
{
        // push token with corresponding type and value to stack
        //cout<<"A TYPE:"<<yytext;
        std::string str(yytext);
        std::string temp;
        int number=0;
        for (unsigned int i=0; i < str.size(); i++)
        {
            if (isdigit(str[i]))
            {
                for (unsigned int a=i; a<str.size(); a++)
                {temp += str[a];
                }
              break;
            }    
        }
        istringstream stream(temp);
        stream >> number;
        //cout<<"With Value:"<<number<<endl; 
        Token temp1(T_VARCHAR,number);
        tokens.push(temp1);
}
	YY_BREAK
case 10:
YY_RULE_SETUP
#line 182 "scanner.l"
{
            //cout<<"A TYPE: " <<yytext<<endl;
            Token temp(T_INTTYPE);
            tokens.push(temp);
}
	YY_BREAK
case 11:
/* rule 11 can match eol */
YY_RULE_SETUP
#line 187 "scanner.l"
{ 
}
	YY_BREAK
case 12:
YY_RULE_SETUP
#line 189 "scanner.l"
{ 
}
	YY_BREAK
case 13:
YY_RULE_SETUP
#line 191 "scanner.l"
{
            // Push token with delete command type to stack 
            //cout<<"DELETE COMMAND"<<endl;
            Token temp(T_DELETE);
            tokens.push(temp);
}
	YY_BREAK
case 14:
YY_RULE_SETUP
#line 197 "scanner.l"
{
            // Push token with create command type to stack
            //cout<<"CREATE COMMAND"<<endl;
            Token temp(T_CREATE);
            tokens.push(temp);
}
	YY_BREAK
case 15:
YY_RULE_SETUP
#line 203 "scanner.l"
{
            // Push token with where command type to stack 
            //cout<<"WHERE COMMAND"<<endl;
            Token temp(T_WHERE);
            tokens.push(temp);
}
	YY_BREAK
case 16:
YY_RULE_SETUP
#line 209 "scanner.l"
{
            // Push token with table type to stack 
            //cout<<"TABLE COMMAND"<<endl;
            Token temp(T_TABLE);
            tokens.push(temp);
}       
	YY_BREAK
case 17:
YY_RULE_SETUP
#line 215 "scanner.l"
{
            // Push left parenthesis to stack
            //cout<<"LEFTPAR"<<endl;
            Token temp(T_LPAR);
            tokens.push(temp);
}
	YY_BREAK
case 18:
YY_RULE_SETUP
#line 221 "scanner.l"
{
            // Push token with word type to stack 
            //cout<<"SET"<<endl;
            Token temp(T_SET);
            tokens.push(temp);
}
	YY_BREAK
case 19:
YY_RULE_SETUP
#line 227 "scanner.l"
{
            // Push right parenthesis token to stack 
            //cout<<"RIGHTPAR"<<endl;
            Token temp(T_RPAR);
            tokens.push(temp); 
}
	YY_BREAK
case 20:
YY_RULE_SETUP
#line 233 "scanner.l"
{
            // Push comma token to stack
            //cout<<"COMMA"<<endl;
            Token temp(T_COMMA);
            tokens.push(temp); 
}
	YY_BREAK
case 21:
YY_RULE_SETUP
#line 239 "scanner.l"
{
            // Push from key word to stack
            //cout<<"COMMAND FROM"<<endl;
            Token temp(T_FROM);
            tokens.push(temp);  
}
	YY_BREAK
case 22:
YY_RULE_SETUP
#line 245 "scanner.l"
{
            // Push primary key token to stack
            //cout<<"PRIMARY KEY RECIEVED"<<endl;
            Token temp(T_PRIMARYKEY);
            tokens.push(temp); 
}
	YY_BREAK
case 23:
YY_RULE_SETUP
#line 251 "scanner.l"
{
            // Push semi colon to stack 
            //cout<<"ENDSENTENCE"<<endl;
            Token temp(T_SEMICOLON);
            tokens.push(temp); 
}
	YY_BREAK
case 24:
YY_RULE_SETUP
#line 257 "scanner.l"
{
            // Push insert command type token to stack 
            //cout<<"INSERT COMMAND"<<endl;
            Token temp(T_INSERT);
            tokens.push(temp);
}
	YY_BREAK
case 25:
YY_RULE_SETUP
#line 263 "scanner.l"
{
            // Push into key word token to stack 
            //cout<<"INTO COMMAND"<<endl;
            Token temp(T_INTO);
            tokens.push(temp);
}
	YY_BREAK
case 26:
YY_RULE_SETUP
#line 269 "scanner.l"
{
            // Push string identifier type token to stack 
            //cout<<"STRING"<<yytext<<endl;
            string s(yytext);
            Token temp(T_STRING, s);
            tokens.push(temp);
}
	YY_BREAK
case 27:
YY_RULE_SETUP
#line 276 "scanner.l"
{
            // Push token with value type to stack 
            //cout<<"GET VALUES COMMAND"<<endl;
            Token temp(T_VALUE);
            tokens.push(temp);
}
	YY_BREAK
case 28:
YY_RULE_SETUP
#line 282 "scanner.l"
{
            // Push token with show command type to stack 
            //cout<<"SHOW COMMAND"<<endl;
            Token temp(T_SHOW);
            tokens.push(temp);
}
	YY_BREAK
case 29:
YY_RULE_SETUP
#line 288 "scanner.l"
{
            // Push token of type left arrow to stack 
            //cout<<"LEFTARROW"<<endl;
            Token temp(T_ASSIGN);
            tokens.push(temp); 
}
	YY_BREAK
case 30:
YY_RULE_SETUP
#line 294 "scanner.l"
{
            // Push token with select command type to stack 
            //cout<<"SELECT COMMAND"<<endl;
            Token temp(T_SELECT);
            tokens.push(temp);
}
	YY_BREAK
case 31:
YY_RULE_SETUP
#line 300 "scanner.l"
{
            // Push token with relation type to stack 
            //cout<<"GET VALUES FROM RELATION"<<endl;
            Token temp(T_RELATION);
            tokens.push(temp);
}
	YY_BREAK
case 32:
YY_RULE_SETUP
#line 306 "scanner.l"
{
            // Push token with project command type to stack 
            //cout<<"PROJECT COMMAND"<<endl;
            Token temp(T_PROJECT);
            tokens.push(temp); 
}
	YY_BREAK
case 33:
YY_RULE_SETUP
#line 312 "scanner.l"
{
            // Push token with rename command type to stack 
            //cout<<"RENAME COMMAND"<<endl;
            Token temp(T_RENAME);
            tokens.push(temp);
}
	YY_BREAK
case 34:
YY_RULE_SETUP
#line 318 "scanner.l"
{
            // Push ampersand type token to stack   
            //cout<<"ONE AND"<<endl;
            Token temp(T_ONEAND);
            tokens.push(temp); 
}
	YY_BREAK
case 35:
YY_RULE_SETUP
#line 324 "scanner.l"
{
            // Push logical and type token to stack 
            //cout<<"COMPARISON(&&)"<<endl;
            Token temp(T_TWOAND);
            tokens.push(temp); 
}
	YY_BREAK
case 36:
YY_RULE_SETUP
#line 330 "scanner.l"
{
            // Push or type token to stack 
            //cout<<"ONE OR"<<endl;
            Token temp(T_ONEOR);
            tokens.push(temp); 
}
	YY_BREAK
case 37:
YY_RULE_SETUP
#line 336 "scanner.l"
{
            // Push logical or type token to stack 
            //cout<<"COMPARISON(||)"<<endl;
            Token temp(T_TWOOR);
            tokens.push(temp);
}
	YY_BREAK
case 38:
YY_RULE_SETUP
#line 342 "scanner.l"
{
            // Push exit command type token to stack 
            //cout<<"EXIT COMMAND"<<endl;
            Token temp(T_EXIT);
            Token temp1(T_SEMICOLON);
            tokens.push(temp); 
            tokens.push(temp1);
}
	YY_BREAK
case 39:
YY_RULE_SETUP
#line 350 "scanner.l"
{
            // Push open command type token to stack 
            //cout<<"OPEN COMMAND"<<endl;
            Token temp(T_OPEN);
            tokens.push(temp); 
}
	YY_BREAK
case 40:
YY_RULE_SETUP
#line 356 "scanner.l"
{
            // Push close command type token to stack 
            //cout<<"CLOSE COMMAND"<<endl;
            Token temp(T_CLOSE);
            tokens.push(temp); 
}
	YY_BREAK
case 41:
YY_RULE_SETUP
#line 362 "scanner.l"
{
            // Push save command type token to stack 
            //cout<<"SAVE COMMAND"<<endl;
            Token temp(T_SAVE);
            tokens.push(temp);
}
	YY_BREAK
case 42:
YY_RULE_SETUP
#line 368 "scanner.l"
{
            // Push update command type token to stack 
            //cout<<"UPDATE COMMAND"<<endl;
            Token temp(T_UPDATE);
            tokens.push(temp);
}
	YY_BREAK
case 43:
YY_RULE_SETUP
#line 374 "scanner.l"
{//cout<<"INPUT ERROR"<<endl;
    ++errors;
}
	YY_BREAK
case 44:
YY_RULE_SETUP
#line 377 "scanner.l"
ECHO;
	YY_BREAK
#line 1403 "lex.yy.c"
case YY_STATE_EOF(INITIAL):
	yyterminate();

	case YY_END_OF_BUFFER:
		{
		/* Amount of text matched not including the EOB char. */
		int yy_amount_of_matched_text = (int) (yy_cp - (yytext_ptr)) - 1;

		/* Undo the effects of YY_DO_BEFORE_ACTION. */
		*yy_cp = (yy_hold_char);
		YY_RESTORE_YY_MORE_OFFSET

		if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
			{
			/* We're scanning a new file or input source.  It's
			 * possible that this happened because the user
			 * just pointed yyin at a new source and called
			 * yylex().  If so, then we have to assure
			 * consistency between YY_CURRENT_BUFFER and our
			 * globals.  Here is the right place to do so, because
			 * this is the first action (other than possibly a
			 * back-up) that will match for the new input source.
			 */
			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
			YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;
			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
			}

		/* Note that here we test for yy_c_buf_p "<=" to the position
		 * of the first EOB in the buffer, since yy_c_buf_p will
		 * already have been incremented past the NUL character
		 * (since all states make transitions on EOB to the
		 * end-of-buffer state).  Contrast this with the test
		 * in input().
		 */
		if ( (yy_c_buf_p) <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
			{ /* This was really a NUL. */
			yy_state_type yy_next_state;

			(yy_c_buf_p) = (yytext_ptr) + yy_amount_of_matched_text;

			yy_current_state = yy_get_previous_state(  );

			/* Okay, we're now positioned to make the NUL
			 * transition.  We couldn't have
			 * yy_get_previous_state() go ahead and do it
			 * for us because it doesn't know how to deal
			 * with the possibility of jamming (and we don't
			 * want to build jamming into it because then it
			 * will run more slowly).
			 */

			yy_next_state = yy_try_NUL_trans( yy_current_state );

			yy_bp = (yytext_ptr) + YY_MORE_ADJ;

			if ( yy_next_state )
				{
				/* Consume the NUL. */
				yy_cp = ++(yy_c_buf_p);
				yy_current_state = yy_next_state;
				goto yy_match;
				}

			else
				{
				yy_cp = (yy_c_buf_p);
				goto yy_find_action;
				}
			}

		else switch ( yy_get_next_buffer(  ) )
			{
			case EOB_ACT_END_OF_FILE:
				{
				(yy_did_buffer_switch_on_eof) = 0;

				if ( yywrap( ) )
					{
					/* Note: because we've taken care in
					 * yy_get_next_buffer() to have set up
					 * yytext, we can now set up
					 * yy_c_buf_p so that if some total
					 * hoser (like flex itself) wants to
					 * call the scanner after we return the
					 * YY_NULL, it'll still work - another
					 * YY_NULL will get returned.
					 */
					(yy_c_buf_p) = (yytext_ptr) + YY_MORE_ADJ;

					yy_act = YY_STATE_EOF(YY_START);
					goto do_action;
					}

				else
					{
					if ( ! (yy_did_buffer_switch_on_eof) )
						YY_NEW_FILE;
					}
				break;
				}

			case EOB_ACT_CONTINUE_SCAN:
				(yy_c_buf_p) =
					(yytext_ptr) + yy_amount_of_matched_text;

				yy_current_state = yy_get_previous_state(  );

				yy_cp = (yy_c_buf_p);
				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
				goto yy_match;

			case EOB_ACT_LAST_MATCH:
				(yy_c_buf_p) =
				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)];

				yy_current_state = yy_get_previous_state(  );

				yy_cp = (yy_c_buf_p);
				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
				goto yy_find_action;
			}
		break;
		}

	default:
		YY_FATAL_ERROR(
			"fatal flex scanner internal error--no action found" );
	} /* end of action switch */
		} /* end of scanning one token */
} /* end of yylex */

/* yy_get_next_buffer - try to read in a new buffer
 *
 * Returns a code representing an action:
 *	EOB_ACT_LAST_MATCH -
 *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
 *	EOB_ACT_END_OF_FILE - end of file
 */
static int yy_get_next_buffer (void)
{
    	register char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
	register char *source = (yytext_ptr);
	register int number_to_move, i;
	int ret_val;

	if ( (yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] )
		YY_FATAL_ERROR(
		"fatal flex scanner internal error--end of buffer missed" );

	if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
		{ /* Don't try to fill the buffer, so this is an EOF. */
		if ( (yy_c_buf_p) - (yytext_ptr) - YY_MORE_ADJ == 1 )
			{
			/* We matched a single character, the EOB, so
			 * treat this as a final EOF.
			 */
			return EOB_ACT_END_OF_FILE;
			}

		else
			{
			/* We matched some text prior to the EOB, first
			 * process it.
			 */
			return EOB_ACT_LAST_MATCH;
			}
		}

	/* Try to read more data. */

	/* First move last chars to start of buffer. */
	number_to_move = (int) ((yy_c_buf_p) - (yytext_ptr)) - 1;

	for ( i = 0; i < number_to_move; ++i )
		*(dest++) = *(source++);

	if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
		/* don't do the read, it's not guaranteed to return an EOF,
		 * just force an EOF
		 */
		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;

	else
		{
			int num_to_read =
			YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;

		while ( num_to_read <= 0 )
			{ /* Not enough room in the buffer - grow it. */

			/* just a shorter name for the current buffer */
			YY_BUFFER_STATE b = YY_CURRENT_BUFFER;

			int yy_c_buf_p_offset =
				(int) ((yy_c_buf_p) - b->yy_ch_buf);

			if ( b->yy_is_our_buffer )
				{
				int new_size = b->yy_buf_size * 2;

				if ( new_size <= 0 )
					b->yy_buf_size += b->yy_buf_size / 8;
				else
					b->yy_buf_size *= 2;

				b->yy_ch_buf = (char *)
					/* Include room in for 2 EOB chars. */
					yyrealloc((void *) b->yy_ch_buf,b->yy_buf_size + 2  );
				}
			else
				/* Can't grow it, we don't own it. */
				b->yy_ch_buf = 0;

			if ( ! b->yy_ch_buf )
				YY_FATAL_ERROR(
				"fatal error - scanner input buffer overflow" );

			(yy_c_buf_p) = &b->yy_ch_buf[yy_c_buf_p_offset];

			num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -
						number_to_move - 1;

			}

		if ( num_to_read > YY_READ_BUF_SIZE )
			num_to_read = YY_READ_BUF_SIZE;

		/* Read in more data. */
		YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
			(yy_n_chars), (size_t) num_to_read );

		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
		}

	if ( (yy_n_chars) == 0 )
		{
		if ( number_to_move == YY_MORE_ADJ )
			{
			ret_val = EOB_ACT_END_OF_FILE;
			yyrestart(yyin  );
			}

		else
			{
			ret_val = EOB_ACT_LAST_MATCH;
			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
				YY_BUFFER_EOF_PENDING;
			}
		}

	else
		ret_val = EOB_ACT_CONTINUE_SCAN;

	if ((yy_size_t) ((yy_n_chars) + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
		/* Extend the array by 50%, plus the number we really need. */
		yy_size_t new_size = (yy_n_chars) + number_to_move + ((yy_n_chars) >> 1);
		YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) yyrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size  );
		if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
			YY_FATAL_ERROR( "out of dynamic memory in yy_get_next_buffer()" );
	}

	(yy_n_chars) += number_to_move;
	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;
	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;

	(yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];

	return ret_val;
}

/* yy_get_previous_state - get the state just before the EOB char was reached */

    static yy_state_type yy_get_previous_state (void)
{
	register yy_state_type yy_current_state;
	register char *yy_cp;
    
	yy_current_state = (yy_start);

	for ( yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp )
		{
		register YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
		if ( yy_accept[yy_current_state] )
			{
			(yy_last_accepting_state) = yy_current_state;
			(yy_last_accepting_cpos) = yy_cp;
			}
		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
			{
			yy_current_state = (int) yy_def[yy_current_state];
			if ( yy_current_state >= 198 )
				yy_c = yy_meta[(unsigned int) yy_c];
			}
		yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
		}

	return yy_current_state;
}

/* yy_try_NUL_trans - try to make a transition on the NUL character
 *
 * synopsis
 *	next_state = yy_try_NUL_trans( current_state );
 */
    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state )
{
	register int yy_is_jam;
    	register char *yy_cp = (yy_c_buf_p);

	register YY_CHAR yy_c = 1;
	if ( yy_accept[yy_current_state] )
		{
		(yy_last_accepting_state) = yy_current_state;
		(yy_last_accepting_cpos) = yy_cp;
		}
	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
		{
		yy_current_state = (int) yy_def[yy_current_state];
		if ( yy_current_state >= 198 )
			yy_c = yy_meta[(unsigned int) yy_c];
		}
	yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
	yy_is_jam = (yy_current_state == 197);

	return yy_is_jam ? 0 : yy_current_state;
}

    static void yyunput (int c, register char * yy_bp )
{
	register char *yy_cp;
    
    yy_cp = (yy_c_buf_p);

	/* undo effects of setting up yytext */
	*yy_cp = (yy_hold_char);

	if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
		{ /* need to shift things up to make room */
		/* +2 for EOB chars. */
		register int number_to_move = (yy_n_chars) + 2;
		register char *dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[
					YY_CURRENT_BUFFER_LVALUE->yy_buf_size + 2];
		register char *source =
				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];

		while ( source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
			*--dest = *--source;

		yy_cp += (int) (dest - source);
		yy_bp += (int) (dest - source);
		YY_CURRENT_BUFFER_LVALUE->yy_n_chars =
			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_buf_size;

		if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
			YY_FATAL_ERROR( "flex scanner push-back overflow" );
		}

	*--yy_cp = (char) c;

	(yytext_ptr) = yy_bp;
	(yy_hold_char) = *yy_cp;
	(yy_c_buf_p) = yy_cp;
}

#ifndef YY_NO_INPUT
#ifdef __cplusplus
    static int yyinput (void)
#else
    static int input  (void)
#endif

{
	int c;
    
	*(yy_c_buf_p) = (yy_hold_char);

	if ( *(yy_c_buf_p) == YY_END_OF_BUFFER_CHAR )
		{
		/* yy_c_buf_p now points to the character we want to return.
		 * If this occurs *before* the EOB characters, then it's a
		 * valid NUL; if not, then we've hit the end of the buffer.
		 */
		if ( (yy_c_buf_p) < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
			/* This was really a NUL. */
			*(yy_c_buf_p) = '\0';

		else
			{ /* need more input */
			int offset = (yy_c_buf_p) - (yytext_ptr);
			++(yy_c_buf_p);

			switch ( yy_get_next_buffer(  ) )
				{
				case EOB_ACT_LAST_MATCH:
					/* This happens because yy_g_n_b()
					 * sees that we've accumulated a
					 * token and flags that we need to
					 * try matching the token before
					 * proceeding.  But for input(),
					 * there's no matching to consider.
					 * So convert the EOB_ACT_LAST_MATCH
					 * to EOB_ACT_END_OF_FILE.
					 */

					/* Reset buffer status. */
					yyrestart(yyin );

					/*FALLTHROUGH*/

				case EOB_ACT_END_OF_FILE:
					{
					if ( yywrap( ) )
						return EOF;

					if ( ! (yy_did_buffer_switch_on_eof) )
						YY_NEW_FILE;
#ifdef __cplusplus
					return yyinput();
#else
					return input();
#endif
					}

				case EOB_ACT_CONTINUE_SCAN:
					(yy_c_buf_p) = (yytext_ptr) + offset;
					break;
				}
			}
		}

	c = *(unsigned char *) (yy_c_buf_p);	/* cast for 8-bit char's */
	*(yy_c_buf_p) = '\0';	/* preserve yytext */
	(yy_hold_char) = *++(yy_c_buf_p);

	return c;
}
#endif	/* ifndef YY_NO_INPUT */

/** Immediately switch to a different input stream.
 * @param input_file A readable stream.
 * 
 * @note This function does not reset the start condition to @c INITIAL .
 */
    void yyrestart  (FILE * input_file )
{
    
	if ( ! YY_CURRENT_BUFFER ){
        yyensure_buffer_stack ();
		YY_CURRENT_BUFFER_LVALUE =
            yy_create_buffer(yyin,YY_BUF_SIZE );
	}

	yy_init_buffer(YY_CURRENT_BUFFER,input_file );
	yy_load_buffer_state( );
}

/** Switch to a different input buffer.
 * @param new_buffer The new input buffer.
 * 
 */
    void yy_switch_to_buffer  (YY_BUFFER_STATE  new_buffer )
{
    
	/* TODO. We should be able to replace this entire function body
	 * with
	 *		yypop_buffer_state();
	 *		yypush_buffer_state(new_buffer);
     */
	yyensure_buffer_stack ();
	if ( YY_CURRENT_BUFFER == new_buffer )
		return;

	if ( YY_CURRENT_BUFFER )
		{
		/* Flush out information for old buffer. */
		*(yy_c_buf_p) = (yy_hold_char);
		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
		}

	YY_CURRENT_BUFFER_LVALUE = new_buffer;
	yy_load_buffer_state( );

	/* We don't actually know whether we did this switch during
	 * EOF (yywrap()) processing, but the only time this flag
	 * is looked at is after yywrap() is called, so it's safe
	 * to go ahead and always set it.
	 */
	(yy_did_buffer_switch_on_eof) = 1;
}

static void yy_load_buffer_state  (void)
{
    	(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
	(yytext_ptr) = (yy_c_buf_p) = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;
	yyin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;
	(yy_hold_char) = *(yy_c_buf_p);
}

/** Allocate and initialize an input buffer state.
 * @param file A readable stream.
 * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.
 * 
 * @return the allocated buffer state.
 */
    YY_BUFFER_STATE yy_create_buffer  (FILE * file, int  size )
{
	YY_BUFFER_STATE b;
    
	b = (YY_BUFFER_STATE) yyalloc(sizeof( struct yy_buffer_state )  );
	if ( ! b )
		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );

	b->yy_buf_size = size;

	/* yy_ch_buf has to be 2 characters longer than the size given because
	 * we need to put in 2 end-of-buffer characters.
	 */
	b->yy_ch_buf = (char *) yyalloc(b->yy_buf_size + 2  );
	if ( ! b->yy_ch_buf )
		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );

	b->yy_is_our_buffer = 1;

	yy_init_buffer(b,file );

	return b;
}

/** Destroy the buffer.
 * @param b a buffer created with yy_create_buffer()
 * 
 */
    void yy_delete_buffer (YY_BUFFER_STATE  b )
{
    
	if ( ! b )
		return;

	if ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */
		YY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;

	if ( b->yy_is_our_buffer )
		yyfree((void *) b->yy_ch_buf  );

	yyfree((void *) b  );
}

#ifndef __cplusplus
extern int isatty (int );
#endif /* __cplusplus */
    
/* Initializes or reinitializes a buffer.
 * This function is sometimes called more than once on the same buffer,
 * such as during a yyrestart() or at EOF.
 */
    static void yy_init_buffer  (YY_BUFFER_STATE  b, FILE * file )

{
	int oerrno = errno;
    
	yy_flush_buffer(b );

	b->yy_input_file = file;
	b->yy_fill_buffer = 1;

    /* If b is the current buffer, then yy_init_buffer was _probably_
     * called from yyrestart() or through yy_get_next_buffer.
     * In that case, we don't want to reset the lineno or column.
     */
    if (b != YY_CURRENT_BUFFER){
        b->yy_bs_lineno = 1;
        b->yy_bs_column = 0;
    }

        b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;
    
	errno = oerrno;
}

/** Discard all buffered characters. On the next scan, YY_INPUT will be called.
 * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.
 * 
 */
    void yy_flush_buffer (YY_BUFFER_STATE  b )
{
    	if ( ! b )
		return;

	b->yy_n_chars = 0;

	/* We always need two end-of-buffer characters.  The first causes
	 * a transition to the end-of-buffer state.  The second causes
	 * a jam in that state.
	 */
	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;

	b->yy_buf_pos = &b->yy_ch_buf[0];

	b->yy_at_bol = 1;
	b->yy_buffer_status = YY_BUFFER_NEW;

	if ( b == YY_CURRENT_BUFFER )
		yy_load_buffer_state( );
}

/** Pushes the new state onto the stack. The new state becomes
 *  the current state. This function will allocate the stack
 *  if necessary.
 *  @param new_buffer The new state.
 *  
 */
void yypush_buffer_state (YY_BUFFER_STATE new_buffer )
{
    	if (new_buffer == NULL)
		return;

	yyensure_buffer_stack();

	/* This block is copied from yy_switch_to_buffer. */
	if ( YY_CURRENT_BUFFER )
		{
		/* Flush out information for old buffer. */
		*(yy_c_buf_p) = (yy_hold_char);
		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
		}

	/* Only push if top exists. Otherwise, replace top. */
	if (YY_CURRENT_BUFFER)
		(yy_buffer_stack_top)++;
	YY_CURRENT_BUFFER_LVALUE = new_buffer;

	/* copied from yy_switch_to_buffer. */
	yy_load_buffer_state( );
	(yy_did_buffer_switch_on_eof) = 1;
}

/** Removes and deletes the top of the stack, if present.
 *  The next element becomes the new top.
 *  
 */
void yypop_buffer_state (void)
{
    	if (!YY_CURRENT_BUFFER)
		return;

	yy_delete_buffer(YY_CURRENT_BUFFER );
	YY_CURRENT_BUFFER_LVALUE = NULL;
	if ((yy_buffer_stack_top) > 0)
		--(yy_buffer_stack_top);

	if (YY_CURRENT_BUFFER) {
		yy_load_buffer_state( );
		(yy_did_buffer_switch_on_eof) = 1;
	}
}

/* Allocates the stack if it does not exist.
 *  Guarantees space for at least one push.
 */
static void yyensure_buffer_stack (void)
{
	int num_to_alloc;
    
	if (!(yy_buffer_stack)) {

		/* First allocation is just for 2 elements, since we don't know if this
		 * scanner will even need a stack. We use 2 instead of 1 to avoid an
		 * immediate realloc on the next call.
         */
		num_to_alloc = 1;
		(yy_buffer_stack) = (struct yy_buffer_state**)yyalloc
								(num_to_alloc * sizeof(struct yy_buffer_state*)
								);
		if ( ! (yy_buffer_stack) )
			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );
								  
		memset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state*));
				
		(yy_buffer_stack_max) = num_to_alloc;
		(yy_buffer_stack_top) = 0;
		return;
	}

	if ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1){

		/* Increase the buffer to prepare for a possible push. */
		int grow_size = 8 /* arbitrary grow size */;

		num_to_alloc = (yy_buffer_stack_max) + grow_size;
		(yy_buffer_stack) = (struct yy_buffer_state**)yyrealloc
								((yy_buffer_stack),
								num_to_alloc * sizeof(struct yy_buffer_state*)
								);
		if ( ! (yy_buffer_stack) )
			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );

		/* zero only the new slots.*/
		memset((yy_buffer_stack) + (yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state*));
		(yy_buffer_stack_max) = num_to_alloc;
	}
}

/** Setup the input buffer state to scan directly from a user-specified character buffer.
 * @param base the character buffer
 * @param size the size in bytes of the character buffer
 * 
 * @return the newly allocated buffer state object. 
 */
YY_BUFFER_STATE yy_scan_buffer  (char * base, yy_size_t  size )
{
	YY_BUFFER_STATE b;
    
	if ( size < 2 ||
	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
	     base[size-1] != YY_END_OF_BUFFER_CHAR )
		/* They forgot to leave room for the EOB's. */
		return 0;

	b = (YY_BUFFER_STATE) yyalloc(sizeof( struct yy_buffer_state )  );
	if ( ! b )
		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_buffer()" );

	b->yy_buf_size = size - 2;	/* "- 2" to take care of EOB's */
	b->yy_buf_pos = b->yy_ch_buf = base;
	b->yy_is_our_buffer = 0;
	b->yy_input_file = 0;
	b->yy_n_chars = b->yy_buf_size;
	b->yy_is_interactive = 0;
	b->yy_at_bol = 1;
	b->yy_fill_buffer = 0;
	b->yy_buffer_status = YY_BUFFER_NEW;

	yy_switch_to_buffer(b  );

	return b;
}

/** Setup the input buffer state to scan a string. The next call to yylex() will
 * scan from a @e copy of @a str.
 * @param yystr a NUL-terminated string to scan
 * 
 * @return the newly allocated buffer state object.
 * @note If you want to scan bytes that may contain NUL values, then use
 *       yy_scan_bytes() instead.
 */
YY_BUFFER_STATE yy_scan_string (yyconst char * yystr )
{
    
	return yy_scan_bytes(yystr,strlen(yystr) );
}

/** Setup the input buffer state to scan the given bytes. The next call to yylex() will
 * scan from a @e copy of @a bytes.
 * @param yybytes the byte buffer to scan
 * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes.
 * 
 * @return the newly allocated buffer state object.
 */
YY_BUFFER_STATE yy_scan_bytes  (yyconst char * yybytes, int  _yybytes_len )
{
	YY_BUFFER_STATE b;
	char *buf;
	yy_size_t n;
	int i;
    
	/* Get memory for full buffer, including space for trailing EOB's. */
	n = _yybytes_len + 2;
	buf = (char *) yyalloc(n  );
	if ( ! buf )
		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_bytes()" );

	for ( i = 0; i < _yybytes_len; ++i )
		buf[i] = yybytes[i];

	buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;

	b = yy_scan_buffer(buf,n );
	if ( ! b )
		YY_FATAL_ERROR( "bad buffer in yy_scan_bytes()" );

	/* It's okay to grow etc. this buffer, and we should throw it
	 * away when we're done.
	 */
	b->yy_is_our_buffer = 1;

	return b;
}

#ifndef YY_EXIT_FAILURE
#define YY_EXIT_FAILURE 2
#endif

static void yy_fatal_error (yyconst char* msg )
{
    	(void) fprintf( stderr, "%s\n", msg );
	exit( YY_EXIT_FAILURE );
}

/* Redefine yyless() so it works in section 3 code. */

#undef yyless
#define yyless(n) \
	do \
		{ \
		/* Undo effects of setting up yytext. */ \
        int yyless_macro_arg = (n); \
        YY_LESS_LINENO(yyless_macro_arg);\
		yytext[yyleng] = (yy_hold_char); \
		(yy_c_buf_p) = yytext + yyless_macro_arg; \
		(yy_hold_char) = *(yy_c_buf_p); \
		*(yy_c_buf_p) = '\0'; \
		yyleng = yyless_macro_arg; \
		} \
	while ( 0 )

/* Accessor  methods (get/set functions) to struct members. */

/** Get the current line number.
 * 
 */
int yyget_lineno  (void)
{
        
    return yylineno;
}

/** Get the input stream.
 * 
 */
FILE *yyget_in  (void)
{
        return yyin;
}

/** Get the output stream.
 * 
 */
FILE *yyget_out  (void)
{
        return yyout;
}

/** Get the length of the current token.
 * 
 */
int yyget_leng  (void)
{
        return yyleng;
}

/** Get the current token.
 * 
 */

char *yyget_text  (void)
{
        return yytext;
}

/** Set the current line number.
 * @param line_number
 * 
 */
void yyset_lineno (int  line_number )
{
    
    yylineno = line_number;
}

/** Set the input stream. This does not discard the current
 * input buffer.
 * @param in_str A readable stream.
 * 
 * @see yy_switch_to_buffer
 */
void yyset_in (FILE *  in_str )
{
        yyin = in_str ;
}

void yyset_out (FILE *  out_str )
{
        yyout = out_str ;
}

int yyget_debug  (void)
{
        return yy_flex_debug;
}

void yyset_debug (int  bdebug )
{
        yy_flex_debug = bdebug ;
}

static int yy_init_globals (void)
{
        /* Initialization is the same as for the non-reentrant scanner.
     * This function is called from yylex_destroy(), so don't allocate here.
     */

    (yy_buffer_stack) = 0;
    (yy_buffer_stack_top) = 0;
    (yy_buffer_stack_max) = 0;
    (yy_c_buf_p) = (char *) 0;
    (yy_init) = 0;
    (yy_start) = 0;

/* Defined in main.c */
#ifdef YY_STDINIT
    yyin = stdin;
    yyout = stdout;
#else
    yyin = (FILE *) 0;
    yyout = (FILE *) 0;
#endif

    /* For future reference: Set errno on error, since we are called by
     * yylex_init()
     */
    return 0;
}

/* yylex_destroy is for both reentrant and non-reentrant scanners. */
int yylex_destroy  (void)
{
    
    /* Pop the buffer stack, destroying each element. */
	while(YY_CURRENT_BUFFER){
		yy_delete_buffer(YY_CURRENT_BUFFER  );
		YY_CURRENT_BUFFER_LVALUE = NULL;
		yypop_buffer_state();
	}

	/* Destroy the stack itself. */
	yyfree((yy_buffer_stack) );
	(yy_buffer_stack) = NULL;

    /* Reset the globals. This is important in a non-reentrant scanner so the next time
     * yylex() is called, initialization will occur. */
    yy_init_globals( );

    return 0;
}

/*
 * Internal utility routines.
 */

#ifndef yytext_ptr
static void yy_flex_strncpy (char* s1, yyconst char * s2, int n )
{
	register int i;
	for ( i = 0; i < n; ++i )
		s1[i] = s2[i];
}
#endif

#ifdef YY_NEED_STRLEN
static int yy_flex_strlen (yyconst char * s )
{
	register int n;
	for ( n = 0; s[n]; ++n )
		;

	return n;
}
#endif

void *yyalloc (yy_size_t  size )
{
	return (void *) malloc( size );
}

void *yyrealloc  (void * ptr, yy_size_t  size )
{
	/* The cast to (char *) in the following accommodates both
	 * implementations that use char* generic pointers, and those
	 * that use void* generic pointers.  It works with the latter
	 * because both ANSI C and C++ allow castless assignment from
	 * any pointer type to void*, and deal with argument conversions
	 * as though doing an assignment.
	 */
	return (void *) realloc( (char *) ptr, size );
}

void yyfree (void * ptr )
{
	free( (char *) ptr );	/* see yyrealloc() for (char *) cast */
}

#define YYTABLES_NAME "yytables"

#line 377 "scanner.l"


#include <iostream>
#include <map>

//Intialized Program
bool Parser::par_program(stack<Token>& theStack, int error_count){
  //  cout<<"Stack SIZE:"<<theStack.size()<<endl;
  reverse_order(theStack); // Swap stack from abc to cba
  if(error_count==0){ //If tokenizer caught errors it i 
    //cout<<"--------------------------------------------------------------"<<endl;
    while(!ordered.empty()){ //Keep popping until nothing is left 
      if(!par_line()){ //call Par_line which calls query or commands
	//	cout<<"INVALID HERE:"<<endl;
	par_empty();//empty the stack
	//cout<<"SIZE OF STACK NOW"<<ordered.size()<<endl;
	list.push_back(false);//Push False value into 
      }
      else {
	//cout<<"VALID HERE1:"<<endl;
	par_empty();//empty stack
	list.push_back(true);//Push True value into 
      }
    }
  }
  if(error_count>0){// if there were errors found ABORT
    //cout<<"INVALID"<<endl;
    list.push_back(false);//Push False value into 
    par_empty();//empty the stack
  }
}

// This prints the vector into terminal and textfile
bool Parser::print_result(string &s){
  int count =0;
  ofstream myfile;
  myfile.open(s.c_str());
  for(int i =0;i<list.size();++i){
    ++count;
    if(list[i]==false) {
      cout<<count<<".)"<<"FALSE"<<endl;
      myfile<<count<<".)"<<"FALSE"<<endl;
    }
    else {
      cout<<count<<".)"<<"TRUE"<<endl;
      myfile<<count<<".)"<<"TRUE"<<endl;
    }	
  }
  myfile.close();	
}
//empty the stack
bool Parser::par_empty(){
  if(!ordered.empty()){
    while(!ordered.empty()){
      ordered.pop();
    }
    return true;
  }
  return false;
}
// return stack size
int Parser::par_stacksize(){
  return ordered.size();
}
//Reverse stack from abc to cba
bool Parser::reverse_order(stack<Token>& theStack){
  size_t temp = theStack.size();
  while(!theStack.empty()){
    ordered.push(theStack.top());
    theStack.pop();
  }
  //cout<<"Parser Stack Size:"<<ordered.size()<<endl;
  if(temp==ordered.size()) return true;
  return false;
}
//checks the first token and calls a function depending on which one is called
bool Parser::par_line(){
  Token temp = ordered.top();
  if(temp.get_type()==T_CREATE||temp.get_type()==T_INSERT||temp.get_type()==T_OPEN||
     temp.get_type()==T_CLOSE||temp.get_type()==T_SAVE||temp.get_type()==T_EXIT||temp.get_type()==T_SHOW||
     temp.get_type()==T_UPDATE||temp.get_type()==T_DELETE){
    //cout<<"PARSER::COMMAND"<<endl;
    if(par_command()){
      if(ordered.empty()){
	//cout<<"INVALID 1:"<<endl;
	return false;
      }
      temp = ordered.top();
      if(temp.get_type()==T_SEMICOLON){ // if it ends in a semicolon, exit the program 
	ordered.pop();
	if(ordered.empty()){
	  //cout<<"VALID"<<endl;
	  return true;
	}
	temp = ordered.top();
	if(temp.get_type()==T_SEMICOLON)// if there are two semicolons it prints false
	  {
	    //cout<<"INVALID 2:"<<endl;
	    return false;
	  }
 	//cout<<"VALID"<<endl;
	// RESET VARS HERE!!!!!!!!!!!!!!!!!!!!!!
	comp_ops.clear();
	return_types.clear();
	recur_depth = 0;
	return true;
      }
      //else cout<<"INVALID 3:"<<endl;
      //cout<<"STACK SIZE:"<<ordered.size()<<endl;
    }
    //else cout<<"INVALID"<<endl; 
  }
  //If it matchs SELECT, PROJEC, RENAME, IDENTIFIER its a query
  if(temp.get_type()==T_SELECT||temp.get_type()==T_PROJECT||temp.get_type()==T_RENAME||temp.get_type()==T_IDENTIFIER){
    //cout<<"PARSER::QUERY"<<endl;
    if(par_query()){
      if(ordered.empty()){
	//cout<<"INVALID 1:"<<endl;
	return false;
      }
      temp = ordered.top();
      if(temp.get_type()==T_SEMICOLON){
	ordered.pop();
	if(ordered.empty()){
	  //cout<<"VALID"<<endl;
	  return true;
	}
	//depending on the token call the correct function
	temp = ordered.top();
	if(temp.get_type()==T_SEMICOLON)
	  {
	    //cout<<"INVALID 2:"<<endl;
	    return false;
	  }
	temp = ordered.top();
	//cout<<"VALID"<<endl;
	return true;
      }
      //else cout<<"INVALID: DOES NOT END IN T_SEMICOLON"<<endl;
      //cout<<"STACK SIZE:"<<ordered.size()<<endl;

    }
  }
  return false; //if none of the above conditions match its not part of our language
}
// If its a command it calls the correlating function to that token
bool Parser::par_command(){
  Token temp = ordered.top();
  if(temp.get_type()==T_CREATE){
    ordered.pop();
    if(par_create()){
      //cout<<"Returned TRUE(CREATE)"<<endl;
      return true;	
    }
  }
  if(temp.get_type()==T_INSERT){
    //cout<<"INSERT COMMAND CALLED"<<endl;
    ordered.pop();
    if(par_insert()){
      //cout<<"Returned TRUE(INSERT)"<<endl;
      return true;
    }
    return false;
  }
  if(temp.get_type()==T_OPEN){
    //ordered.pop();
    if(par_open()){
      return true;
    }
  }
  if(temp.get_type()==T_CLOSE){
    //ordered.pop();
    if(par_close()){
      //cout<<"RETURNED TRUE(CLOSE)"<<endl;
      
      return true;
    }
  }
  if(temp.get_type()==T_SAVE){
    //ordered.pop();
    if(par_save()){
      //cout<<"RETURNED TRUE(SAVE)"<<endl;
      return true;
    }
  }
  if(temp.get_type()==T_EXIT){
    //ordered.pop();
    if(par_exit()){
      //cout<<"RETURNED TRUE(EXIT)"<<endl;
      return true;
    }
  }
  if(temp.get_type()==T_SHOW){
    //ordered.pop();
    if(par_show()){
      //cout<<"RETURNED TRUE(SHOW)"<<endl;
      return true;
    }
  }
  if(temp.get_type()==T_UPDATE){
    //ordered.pop();
    if(par_update()){
      //cout<<"RETURNED TRUE(UPDATE)"<<endl;
      return true;
    }
  }
  if(temp.get_type()==T_DELETE){
    //ordered.pop();
    if(par_delete()){
      //cout<<"RETURNED TRUE(DELETE)"<<endl;
      return true;				
    }
  }
  return false; //if its not any of these its not one of our commands
}
//Calls the correlating query function
bool Parser::par_query(){
  Token temp = ordered.top();
  if(temp.get_type()==T_SELECT){
    if(par_selection()){
      //cout<<"RETURNED TRUE(SELECT)"<<endl;
      return true;
    }
  }
  if(temp.get_type()==T_PROJECT){
    if(par_projection()){
      //cout<<"RETURNED TRUE(PROJECT)"<<endl;
      return true;
    }
  }
  if(temp.get_type()==T_RENAME){
    if(par_renaming()){
      //cout<<"RETURNED TRUE(RENAME)"<<endl;
      return true;
    }
  }
  if(temp.get_type()==T_IDENTIFIER){
    if(par_execute_query()){
      //cout<<"RETURNED TRUE(EXECUTE QUERY)"<<endl;
      return true;
    }
  }
  return false; //if none of these functions exit
}
//If it starts with an identifier it comes here first
bool Parser::par_execute_query(){
  Token temp = ordered.top();
  if(par_relationName()){ 
    temp=ordered.top();
    if(temp.get_type()==T_ASSIGN){// Looks for an arrow
      //cout<<"FOUND LEFT ARROW"<<endl;
      ordered.pop();
      if(par_expression()){
	return true;
      }
      //cout<<"Returning False par_execute_query"<<endl;
      return false;
    }
  }
  else return false;
}
//If create was the first token it comes here.
//CREATE TABLE relation-name ( typed-attribute-list ) PRIMARY KEY ( attribute-list )
bool Parser::par_create(){
  Token temp = ordered.top();
  int count_commas =0;
  int count_types = 0;
  table_list new_tbl;
  vector<string> attrs;
  vector<string> prim_keys;
  create_attrs = {}; 
  if(temp.get_type()==T_TABLE)
    {
      ordered.pop();
      string tbl = ordered.top().get_string_value();
      if(par_relationName()){
	temp=ordered.top();
	if(temp.get_type()==T_LPAR){
	  ordered.pop();
	  //cout<<"IN CREATE LOOKING FOR T_RPAR"<<endl;
	  while(temp.get_type()!=T_RPAR){
	    if(ordered.empty()){
	      //cout<<"INVALID(CREATE): STACK EMPTY"<<endl;
	      return false;
	    }
	    temp = ordered.top();
	    // CAPTURE ATTRIBUTES
	    create_attrs.push_back(temp.get_string_value());
	    attrs.push_back(ordered.top().get_string_value());
	    if(par_relationName()){
	      temp = ordered.top();
	      if(temp.get_type()==T_VARCHAR||T_INTTYPE){
		ordered.pop();
		//cout<<"FOUND TYPE T_VARCHAR||T_INTTYPE"<<endl;
		++count_types;
		temp =ordered.top();
		if(temp.get_type()==T_COMMA){
		  ordered.pop();
		  temp = ordered.top();
		  //cout<<"Popping COMMA(CREATE)"<<endl;
		  ++count_commas;
		  if(ordered.empty()){
		    //cout<<"INVALID(CREATE): STACK EMPTY"<<endl;
		    return false;
		  }

		}
							
	      }

	    }
	    temp = ordered.top();
	    //cout<<"\n"<<"THIS IS A "<<temp.get_type_string()<<endl;
	    if((temp.get_type()!=T_COMMA) && temp.get_type()!=T_IDENTIFIER && temp.get_type()!=T_RPAR && temp.get_type()!=T_VARCHAR && T_INTTYPE){
	      //cout<<"RETURN FLASE(CREATE)2"<<endl;
	      return false;
	    }

	  }
	  //cout<<"Count_Commas:"<<count_commas<<"count_types"<<count_types<<endl;
	  if(count_commas==count_types-1){}//{cout<<"IN HERE"<<endl;}
	  else {//cout<<"COMMAS DONT MATCH # of TYPES"<<endl;return false;
	  }
	  count_commas=0;
	  count_types=0; 
	  temp = ordered.top();
	  //cout<<"FOUND T_RPAR"<<endl;
	  if(temp.get_type()==T_RPAR){
	    ordered.pop();
	    temp=ordered.top();
	    if(temp.get_type()==T_PRIMARYKEY){
	      //cout<<"FOUND PRIMARY KEY(CREATE):"<<endl;
	      ordered.pop();
	      temp=ordered.top();
	      if(temp.get_type()==T_LPAR){
		ordered.pop();
		temp=ordered.top();
		while(temp.get_type()!=T_RPAR){
		  if(ordered.empty()){
		    //cout<<"INVALID(CREATE): STACK EMPTY"<<endl;
		    return false;
		  }
		  // GET PRIMARY KEYS HERE
		  prim_keys.push_back(ordered.top().get_string_value());
		  if(par_relationName()){
		    ++count_types;
		    temp = ordered.top();
		    if(ordered.empty()){
		      //cout<<"INVALID(CREATE): STACK EMPTY"<<endl;
		      return false;
		    }
		    if(temp.get_type()==T_COMMA){
		      //cout<<"POPPING COMMA"<<endl;
		      ++count_commas;
		      if(ordered.empty()){
			//cout<<"INVALID(CREATE): STACK EMPTY"<<endl;
			return false;
		      }
		      ordered.pop();
		      temp = ordered.top();
		    }
		  }
		  else return false;
		}
		//cout<<"Count_Commas:"<<count_commas<<"count_types"<<count_types<<endl;
		if(count_commas==count_types-1){}//{cout<<"IN HERE"<<endl;}
		else {
		  //cout<<"COMMAS DONT MATCH # of TYPES"<<endl;return false;
		}
		temp=ordered.top();
		if(temp.get_type()==T_RPAR){
		  //cout<<"FOUND T_RPAR"<<endl;
		  if(ordered.empty()){
		    //cout<<e"INVALID(CREATE): STACK EMPTY"<<endl;
		    return false;
		  }
		  ordered.pop();

		  // MAKE TABLE HERE...
		  table t = db.create(attrs, prim_keys);
		  //	  db.show(t);
		  db.save(t, tbl + ".db");
		  db.print_db();
		  return true;
		}
	      }
	      return false;
	    }
	    return false;

	  }
	  return false;
	}
	return false;
      }
    }
  return false;
}
//INSERT INTO relation-name VALUES FROM ( literal { , literal } )
//INSERT INTO relation-name VALUES FROM RELATION expr
bool Parser::par_insert(){
  Token temp = ordered.top();
  vector<string> vals;
  table_list t = db.return_DB();
  string s;

  if(temp.get_type()==T_INTO){
    ordered.pop();
    //cout<<"MADE IT HERE INTO"<<endl;
    Token temp = ordered.top();
    string tbl =  temp.get_string_value();
    if(par_relationName())
      {	
	//cout<<"MADE IT HERE INTO par_relationName"<<endl;
	Token temp = ordered.top();
	if(temp.get_type()==T_VALUE){
	  ordered.pop();
	  //cout<<"MADE IT HERE INTO T_VALUE"<<endl;
	  Token temp = ordered.top();
	  if(temp.get_type()==T_FROM){
	    ordered.pop();
	    //cout<<"MADE IT HERE INTO T_FROM"<<endl;
	    Token temp = ordered.top();
	    if(temp.get_type()==T_LPAR){
	      //cout<<"Popping T_LPAR INSERT"<<endl;
	      ordered.pop();
	      //cout<<"MADE IT HERE INTO T_LPAR"<<endl;
	      Token temp = ordered.top();
	      //cout<<"Searching for T_RPAR"<<endl;
	      while(temp.get_type()!=T_RPAR){
		if(ordered.empty()){
		  //cout<<"INVALID: STACK EMPTY"<<endl;
		  return false;
		}
		//cout << ordered.top().get_string_value() << endl;
		//		vals.push_back(temp.get_string_value());
		if (ordered.top().get_type() == T_STRING &&
		    ordered.top().get_string_value().find_first_not_of(' ') !=
		    string::npos) {
		  s = ordered.top().get_string_value();
		  vals.push_back(s.substr(1, s.size() - 2));
		}
		else if (ordered.top().get_type() == T_INTVALUE ||
			 ordered.top().get_type() == T_DOUBLEVALUE) {
		  vals.push_back(to_string(ordered.top().get_num()));
		}
		else{}

		if(par_literals()){
		  if(ordered.empty()){
		    //cout<<"INVALID: STACK EMPTY"<<endl;
		    return false;
		  }
		  temp = ordered.top();
		}
		if(temp.get_type()==T_COMMA){
		  //cout<<"FOUND COMMA"<<endl;
		  ordered.pop();
		  // EXPAND OPTIONS?
		  if (ordered.top().get_type() == T_STRING &&
		      ordered.top().get_string_value().find_first_not_of(' ') !=
		      string::npos) {
		    s = ordered.top().get_string_value();
		    vals.push_back(s.substr(1, s.size() - 2));
		  }
		  else if (ordered.top().get_type() == T_INTVALUE ||
			   ordered.top().get_type() == T_DOUBLEVALUE) {
		    vals.push_back(to_string(ordered.top().get_num()));
		  }
		  else{}

		  if(par_literals()){
		    if(ordered.empty()){
		      //cout<<"INVALID: STACK EMPTY"<<endl;
		      return false;
		    }
		    temp = ordered.top();
		  }
		  else return false;
									
		}
		else return false;
	      }
	      temp = ordered.top();
	      if(temp.get_type()==T_RPAR){
		//cout<<"Found T_RPAR"<<endl;
		ordered.pop();
		//Token temp = ordered.top();

		// Do insertion
		int rowCt = 0;
		
		for (auto it : t[tbl]) {
		  if (it.first == "$primary_key") {
		    cout << "rar" << endl;
		    insert_vals[it.first] = {it.second[0]};
		  }
		  else {
		    insert_vals[it.first] = {vals[vals.size() - 1 - rowCt]};
		    ++rowCt;
		  }
		 
		}
		
		table new_table = db.insert_tuple(tbl, insert_vals);
		db.show(insert_vals);
		return true;
	      }	
	    }
	    //INSERT INTO relation-name VALUES FROM RELATION expr
	    temp = ordered.top();
	    //cout<<"INSERTING INTO FROM RELATION:"<<endl;
	    if(temp.get_type()==T_RELATION){
	      ordered.pop();
	      
	      // LoGIC TO CREATE TABLE FROM WHATEVER FUNCTION
	      	
	      Token t = ordered.top();
	      if(par_expression()){
		switch(t.get_type()) {
		case T_PROJECT:
		  db.open(tbl);
		  table new_table = db.insert_tuple(tbl, project_vals);
		  //db.show(project_vals);
		  break;
		}

		return true;
	      }

	    }

	  }
	}
      }
    return false;
  }	
  return false;
}
/*expr ::= atomic-expr
  | selection
  | projection
  | renaming
  | union
  | difference
  | product*/
bool Parser::par_expression(){
  Token temp = ordered.top();
  if(par_selection()){
    //cout<<"SELECT RETURNED TRUE(Expression)"<<endl;
    return true;
  }
  if(par_projection()){
    //cout<<"PROJECT RETURNED TRUE(Expression)"<<endl;
    return_types.push_back(T_PROJECT);
    ++recur_depth;
    return true;
  }
  if(par_renaming()){
    //cout<<"RENAMING RETURNED TRUE(Expression)"<<endl;
    return true;
  }
  if(par_atomicexpression()){
    Token temp = ordered.top();
    //cout<<"MADE IT HERE(par_atomicexpression"<<endl;
    //SET UNION
    if(temp.get_type()==T_PLUS){
      ordered.pop();
      //cout<<"Popping PLUS(Atomic_Expression)"<<endl;
      temp = ordered.top();
      if(par_atomicexpression()){
	temp =ordered.top();
	//if(temp.get_type()==T_RPAR) ordered.pop();
	//	cout<<"Returning True Atomic_Expression"<<endl;
	return true;
      }
      return false;
    }
    //SET DIFFERENCE
    if(temp.get_type()==T_MINUS){
      ordered.pop();
      temp = ordered.top();
      if(par_atomicexpression()){
	return true;
      }
      return false;
    }
    if(temp.get_type()==T_MULTIPLY){
      ordered.pop();
      temp = ordered.top();
      if(par_atomicexpression()){
	return true;
      }
      return false;
    }
    //cout<<"Atomic RETURNED TRUE(Expression)"<<endl;
    return true;
  }
  return false;
}
// atomic-expr ::= relation-name | ( expr )
bool Parser::par_atomicexpression(){
  Token temp = ordered.top();
  if(temp.get_type()==T_LPAR){
    if(ordered.empty()){
      //cout<<"INVALID: STACK EMPTY"<<endl;
      return false;
    }
    ordered.pop();
    //cout<<"Popping T_LPAR(par_atomicexpression)"<<endl;
    if(ordered.empty()){
      //cout<<"INVALID: STACK EMPTY"<<endl;
      return false;
    }
    if(par_expression()){
      temp = ordered.top();
      if(temp.get_type()==T_RPAR){
	ordered.pop();
	if(ordered.empty()){
	  //cout<<"INVALID: STACK EMPTY"<<endl;
	  return false;
	}
	return true;
      }
      else return false;
    }
  }
  else if(par_relationName()) return true;
  return false; 
}
//relation-name ::= identifier
bool Parser::par_relationName(){
  Token temp = ordered.top();
  if(temp.get_type()==T_IDENTIFIER){
    //cout<<"FOUND T_IDENTIFIER (par_relationName) "<<temp.get_string_value()<<endl;
    ordered.pop();
    if(ordered.empty()){
      //cout<<"INVALID(RELATION NAME): STACK EMPTY"<<endl;
      return false;
    }
    return true;
  }
  else return false;
}
// relation-name ::= identifier
bool Parser::par_literals(){
  if(ordered.empty()){
    //cout<<"INVALID(LITERAL): STACK EMPTY"<<endl;
    return false;
  }
  Token temp = ordered.top();
  if(temp.get_type()==T_STRING){
    //cout<<"FOUND LITERAL:"<<temp.get_string_value()<<endl;
    ordered.pop();
    if(ordered.empty()){
      //cout<<"INVALID(LITERAL): STACK EMPTY"<<endl;
      return false;
    }
    return true;
  }
  else if(temp.get_type()==T_INTVALUE){
    //cout<<"FOUND LITERAL:"<<temp.get_num()<<endl;
    ordered.pop();
    if(ordered.empty()){
      //cout<<"INVALID(LITERAL): STACK EMPTY"<<endl;
      return false;
    }
    return true;
  }
  else if(temp.get_type()==T_DOUBLEVALUE){
    //cout<<"FOUND LITERAL:"<<temp.get_num()<<endl;
    ordered.pop();
    if(ordered.empty()){
      //cout<<"INVALID(LITERAL): STACK EMPTY"<<endl;
      return false;
    }
    return true;
  }

  return false;
}
//select ( condition ) atomic-expr
bool Parser::par_selection(){
  Token temp = ordered.top();
  string tbl;
  table new_table;
  table_list t = db.return_DB();
  if(temp.get_type()==T_SELECT){
    //cout<<"SELECT COMMAND CALLED"<<endl;
    //cout<<"Popped Select"<<endl;
    ordered.pop();
    if(ordered.empty()){
      //cout<<"INVALID(SELECT): STACK EMPTY"<<endl;
      return false;
    }
    temp = ordered.top();
    if(temp.get_type()==T_LPAR){
      ordered.pop();
      if(ordered.empty()){
	//cout<<"INVALID(SELECT): STACK EMPTY"<<endl;
	return false;
      }
      //cout<<"POPPED T_LPAR"<<endl;
      if(par_condition()){
	//cout<<"par_condition returned true:"<<endl;
	temp = ordered.top();
	if(temp.get_type()==T_RPAR){
	  ordered.pop();
	  //cout<<"POPPED T_RPAR"<<endl;
	  temp=ordered.top();
	  tbl = temp.get_string_value();
	  if(par_atomicexpression()) {
	    new_table = t[tbl];
	    vector<string> cmp;
	    for (int i = 0; i < comp_ops.size(); ++i) {
	      cmp = comp_ops[i];
	      new_table = db.selection(new_table, cmp[0], cmp[1], cmp[2]);
	    }			  
	    return true;
	  }
	}
      }
      //cout<<"Selection Returning False:"<<endl;
      return false;	
    }
  }
  return false;
}
// condition ::= conjunction { || conjunction }
bool Parser::par_condition(){
  //cout<<"Conditon Called"<<endl;
  Token temp = ordered.top();
  if(par_conjuction()){
    temp = ordered.top();
    if(temp.get_type()==T_TWOOR){
      temp = ordered.top();
      while(temp.get_type()==T_TWOOR){
	ordered.pop();
	//cout<<"Popping TWOOR"<<endl;
	if(par_conjuction()){
	  //cout<<"IN HERE BOI(Conjuction)"<<endl;
	}
	temp = ordered.top();
      }
    }
    //cout<<"Returning TRUE(Conditon):"<<endl;
    return true;
  }
  //cout<<"Returning false(Conditon):"<<endl;
  return false;
}
// conjunction ::= comparison { && comparison }
bool Parser::par_conjuction(){
  //cout<<"Conjuction Called"<<endl;
  Token temp = ordered.top();
  if(par_comparison()){
    temp = ordered.top();
    //cout<<"CHECK THIS JOINT OUT:" <<temp.get_type_string()<<endl;
    if(temp.get_type()==T_TWOAND){
      temp = ordered.top();
      //cout<<"Entering While Loop(Conjuction)"<<temp.get_type_string()<<endl;
      while(temp.get_type()==T_TWOAND){
	//cout<<"Popping TWOAND(Conjuction)"<<endl;
	ordered.pop();
	if(par_comparison()){
	  //cout<<"IN HERE BOI(Conjuction)"<<endl;
	}
	temp = ordered.top();
      }
    }
    //cout<<"Returning TRUE(CONJUCTION)"<<endl;
    return true;
  }
  //cout<<"Returning False(CONJUCTION)"<<endl;
  return false;
}
//comparison ::= operand op operand | ( condition )
bool Parser::par_comparison(){
  string opr1, op, opr2;
  //cout<<"Comparison Called"<<endl;
  Token temp = ordered.top();
  opr1 = ordered.top().get_string_value();
  if(par_operand()){
    op = ordered.top().get_string_value();
    if(par_op()){
      opr2 = ordered.top().get_string_value();
      if(par_operand()){
	vector<string> opset = {opr1, op, opr2};
	cout << "OPS: " + opr1 + ' ' + op + ' ' + opr2 << endl;
	comp_ops.push_back(opset);
	//cout<<"Return True(Comparison)"<<endl;
	return true;
      }
      return false;
    }
    return false;
  }
  if(ordered.empty()){
    //cout<<"INVALID(Comparison): STACK EMPTY"<<endl;
    return false;
  }
  temp =ordered.top();
  if(temp.get_type()==T_LPAR){
    //cout<<"Popping T_LPAR Comparison"<<endl;
    ordered.pop();
    if(ordered.empty()){
      //cout<<"INVALID(Comparison): STACK EMPTY"<<endl;
      return false;
    }
    temp = ordered.top();
    while(temp.get_type()!=T_RPAR){
      if(par_condition()){
	temp = ordered.top();
      }
      else return false;
    }
    temp = ordered.top();
    if(temp.get_type()==T_RPAR){
      //cout<<"Popping T_RPAR Comparison"<<endl;
      ordered.pop();
      if(ordered.empty()){
	//cout<<"INVALID(Comparison): STACK EMPTY"<<endl;
	return false;
      }
      cout << "sdss" << endl;
      return true;
    }
  }
  return false;
}
//operand ::= attribute-name | literal
bool Parser::par_operand(){
  //cout<<"Operand Called"<<endl;
  Token temp = ordered.top();
  if(par_relationName()){
    return true;
  }
  if(par_literals()){
    return true;
  }
  //cout<<"Returning FALSE(OPERAND)"<<endl;
  return false;
}
//op ::= == | != | < | > | <= | >=
bool Parser::par_op(){
  //cout<<"OP Called"<<endl;
  Token temp = ordered.top();
  if(temp.get_type()==T_TWOEQUALS){
    //cout<<"Popping == "<<endl;
    ordered.pop();
    if(ordered.empty()){
      //cout<<"INVALID: STACK EMPTY"<<endl;
      return false;
    }
    return true;
  }
  if(temp.get_type()==T_NOTEQUAL){
    //cout<<"Popping != "<<endl;
    ordered.pop();
    if(ordered.empty()){
      //cout<<"INVALID: STACK EMPTY"<<endl;
      return false;
    }
    return true;
  }
  if(temp.get_type()==T_LESS){
    //cout<<"Popping < "<<endl;
    ordered.pop();
    if(ordered.empty()){
      //cout<<"INVALID: STACK EMPTY"<<endl;
      return false;
    }
    return true;
  }
  if(temp.get_type()==T_LESSEQUAL){
    //cout<<"Popping <= "<<endl;
    ordered.pop();
    if(ordered.empty()){
      //cout<<"INVALID: STACK EMPTY"<<endl;
      return false;
    }
    return true;
  }
  if(temp.get_type()==T_GREATER){
    //cout<<"Popping > "<<endl;
    ordered.pop();
    if(ordered.empty()){
      //cout<<"INVALID: STACK EMPTY"<<endl;
      return false;
    }
    return true;
  }
  if(temp.get_type()==T_GREATEREQUAL){
    //cout<<"Popping >= "<<endl;
    ordered.pop();
    if(ordered.empty()){
      //cout<<"INVALID: STACK EMPTY"<<endl;
      return false;
    }
    return true;
  }
  //cout<<"Returning False: OP"<<endl;
  return false;
}
//projection ::= project ( attribute-list ) atomic-expr
bool Parser::par_projection(){
  Token temp = ordered.top();
  //table project_vals;
  vector<string> attrs;
  if(temp.get_type()==T_PROJECT){
    //cout<<"Popping Project(PROJECT)"<<endl;
    ordered.pop();
    temp = ordered.top();
    if(temp.get_type()==T_LPAR){
      if(ordered.empty()){
	//cout<<"INVALID: STACK EMPTY"<<endl;
	return false;
      }
      ordered.pop();
      //cout<<"Popped T_LPAR"<<endl;
      if(ordered.empty()){
	//cout<<"INVALID: STACK EMPTY"<<endl;
	return false;
      }
      temp = ordered.top();
      //cout<<"IN PROJECTION LOOKING FOR T_RPAR"<<endl;
      while(temp.get_type()!=T_RPAR){
	if(ordered.empty()){
	  //cout<<"INVALID(PROJECTION): STACK EMPTY"<<endl;
	  return false;
	}
	
	attrs.push_back(ordered.top().get_string_value());
	if(par_relationName()){
	  temp = ordered.top();
	  if(ordered.empty()){
	    //cout<<"INVALID(PROJECTION): STACK EMPTY"<<endl;
	    return false;

	  }
	  if(temp.get_type()==T_COMMA){
	    if(ordered.empty()){
	      //cout<<"INVALID: STACK EMPTY"<<endl;
	      return false;
	    }
	    ordered.pop();
	    //cout<<"Popping Comma (PROJECTION):"<<endl;
	    temp = ordered.top();
	  }
	}
	else return false;

      }
      //cout<<"FOUND T_RPAR(PROJECTION)"<<endl;
      ordered.pop();
      if(ordered.empty()){
	//cout<<"INVALID(PROJECTION): STACK EMPTY"<<endl;
	return false;
      }
      string tbl = ordered.top().get_string_value();
      if(par_atomicexpression()){
	//cout << "db.projection(" + tbl + ", " + "attrs);" << endl;
	project_vals = db.projection(tbl, attrs);
	//db.show(project_vals);
	return true;
      }
      else return false;
    }
  }

  return false;
}
//open-cmd ::== OPEN relation-name
bool Parser::par_open(){
  //cout<<"PARSER(OPEN)"<<endl;
  Token temp = ordered.top();
  if(temp.get_type()==T_OPEN){
    ordered.pop();
    if(ordered.empty()){
      //cout<<"INVALID: STACK EMPTY"<<endl;
      return false;
    }
    string tbl = ordered.top().get_string_value();
    if(par_relationName()){
      cout << "db.open(\"" + tbl + "\");" << endl;
      db.open(tbl);
      //db.print_db();
      return true;
    }
    return false;
  }
  else return false;
}
// close-cmd ::== CLOSE relation-name 
bool Parser::par_close(){
  Token temp = ordered.top();
  //cout<<"CLOSE COMMAND REQUESTED"<<endl;
  if(temp.get_type()==T_CLOSE){
    ordered.pop();
    if(ordered.empty()){
      //cout<<"INVALID: STACK EMPTY"<<endl;
      return false;
    }
    string tbl = (ordered.top()).get_string_value();
    if(par_relationName()){
      db.close(tbl);
      return true;
    }
    else return false;

  }
  return false;


}
// save-cmd ::== SAVE relation-name 
bool Parser::par_save(){
  Token temp = ordered.top();
  //cout<<"SAVE COMMAND REQUESTED"<<endl;
  if(temp.get_type()==T_SAVE){
    ordered.pop();
    if(ordered.empty()){
      //cout<<"INVALID: STACK EMPTY"<<endl;
      return false;
    }
    string tbl = (ordered.top()).get_string_value() + ".db";
    if(par_relationName()){
      table_list t = db.return_DB();
      db.save(t[tbl], tbl);
      return true;
    }
    else return false;

  }
  return false;

}
// exit-cmd ::== EXIT 
bool Parser::par_exit(){
  Token temp = ordered.top();
  //cout<<"EXIT COMMAND REQUESTED"<<endl;
  if(temp.get_type()==T_EXIT){
    ordered.pop();
    if(ordered.empty()){
      //  cout<<"INVALID: STACK EMPTY"<<endl;
      return false;
    }
    cout << "db.exit()" << endl;
    db.exit();
    return true;
  }
  return false;
}
// show-cmd ::== SHOW atomic-expr 
bool Parser::par_show(){
  Token temp = ordered.top();
  //cout<<"SHOW COMMAND REQUESTED"<<endl;
  if(temp.get_type()==T_SHOW){
    ordered.pop();
    if(ordered.empty()){
      //cout<<"INVALID: STACK EMPTY"<<endl;
      return false;
    }
    string tbl = (ordered.top()).get_string_value();
    if(par_atomicexpression()){
      cout << "db.show(\"" + tbl + "\");" << endl;
      db.show(tbl);
      return true;
    }
    else return false;

  }
  return false;
}
// update-cmd ::= UPDATE relation-name SET attribute-name = literal { , attribute-name = literal } WHERE condition 
bool Parser::par_update(){
  vector<string> attrs;
  vector<string> vals;
  string s;
  Token temp = ordered.top();
  if(temp.get_type()==T_UPDATE){
    //cout<<"In UPDATE"<<endl;
    //cout<<"Popping UPDATE"<<endl;
    ordered.pop();
    attrs.push_back(ordered.top().get_string_value());
    if(par_relationName()){
      temp = ordered.top();
      if(temp.get_type()==T_SET){
	ordered.pop();
	//cout<<"Popping SET(UPDATE)"<<endl;
	temp=ordered.top();
	attrs.push_back(ordered.top().get_string_value());
	if(par_relationName()){
	  temp = ordered.top();
	  if(temp.get_type()==T_EQUAL){
	    ordered.pop();
	    //cout<<"Popping SET(UPDATE)"<<endl;
	    temp = ordered.top();
	    s = temp.get_string_value();	    
	    vals.push_back(s.substr(1, s.size() - 2));
	    if(par_literals()){
	      temp = ordered.top();
	      //cout<<"BEFORE HITTING WHILE LOOP:"<<temp.get_type_string()<<endl;
	      while(temp.get_type()!=T_WHERE){
		//cout<<"LOOKING FOR WHERE(UPDATE)"<<endl;
		temp = ordered.top();
		if(temp.get_type()==T_COMMA){
		  ordered.pop();
		  //cout<<"Popping COMMA(UPDATE)"<<endl;
		  attrs.push_back(ordered.top().get_string_value());
		  if(par_relationName()){
		    temp = ordered.top();
		    if(temp.get_type()==T_EQUAL){
		      ordered.pop();
		      //cout<<"Popping EQUAL(UPDATE)"<<endl;
		      s = ordered.top().get_string_value();
		      vals.push_back(s.substr(1, s.size() - 2));
		      if(par_literals()){
			temp = ordered.top();
			
			// Do something with these literals!
		      }
		      else return false;
		    }
		    else return false;
		  }
		}
		else return false;
	      }
	      temp = ordered.top();
	      cout<<"Found WHERE (UPDATE)"<<endl;
	      ordered.pop();
	      if(par_condition()){ 
		for (int i = 0; i < comp_ops.size(); ++i) {
		  for (int j = 0; j < comp_ops[i].size(); ++j) {
		    cout << comp_ops[i][j] << ' ';
		  }
		  cout << endl;
		}
		return true;
	      }
	      return false;
	    }
	  }
	}
      }
    }
  }
  return false;
}
// delete-cmd ::= DELETE FROM relation-name WHERE condition
bool Parser::par_delete(){
  Token temp = ordered.top();
  string del_tbl, cond_attr, op, cond_val;
  if(temp.get_type()==T_DELETE){
    ordered.pop();
    //cout<<"IN DELETE"<<endl;
    if(ordered.empty()){
      //cout<<"INVALID: STACK EMPTY"<<endl;
      return false;
    }
    temp = ordered.top();
    if(temp.get_type()==T_FROM){
      ordered.pop();
      if(ordered.empty()){
	//cout<<"INVALID: STACK EMPTY"<<endl;
	return false;
      }
      temp = ordered.top();
      del_tbl = temp.get_string_value();
      if(par_relationName()){
	temp = ordered.top();
	if(temp.get_type()==T_WHERE){
	  ordered.pop();
	  if(ordered.empty()){
	    //cout<<"INVALID: STACK EMPTY"<<endl;
	    return false;
	  }
	  temp = ordered.top();
	  if(par_conjuction()){
	    for (int i = 0; i < comp_ops.size(); ++i) {
	      vector<string> ops = comp_ops[i];
	      db.delete_tuple(del_tbl, ops[0], ops[1], ops[2]);
	      cout << ops[0] << ' '<< ops[1] << ' ' << ops[2] << endl;
	    }
	    //db.delete(del_tbl, cond_attr, op, cond_val);
	    return true;
	  }
	}
      }
    }
  }
  return false;
}
// renaming ::= rename ( attribute-list ) atomic-expr
bool Parser::par_renaming(){
  Token temp = ordered.top();
  vector<string> new_names;
  table_list t = db.return_DB();
  if(temp.get_type()==T_RENAME){
    //cout<<"RENAMING CALLED"<<endl;
    //cout<<"Popping Renaming (Renaming)"<<endl;
    ordered.pop();
    temp = ordered.top();
    if(temp.get_type()==T_LPAR){
      if(ordered.empty()){
	//cout<<"INVALID: STACK EMPTY"<<endl;
	return false;
      }
      ordered.pop();
      //cout<<"Popped T_LPAR"<<endl;
      if(ordered.empty()){
	//cout<<"INVALID: STACK EMPTY"<<endl;
	return false;
      }
      temp = ordered.top();
      //cout<<"IN Renaming LOOKING FOR T_RPAR"<<endl;
      while(temp.get_type()!=T_RPAR){
	if(ordered.empty()){
	  //cout<<"INVALID(Renaming): STACK EMPTY"<<endl;
	  return false;
	}
	new_names.push_back(ordered.top().get_string_value());
	if(par_relationName()){
	  temp = ordered.top();
	  if(ordered.empty()){
	    //cout<<"INVALID(Renaming): STACK EMPTY"<<endl;
	    return false;

	  }
	  if(temp.get_type()==T_COMMA){
	    if(ordered.empty()){
	      //cout<<"INVALID: STACK EMPTY"<<endl;
	      return false;
	    }
	    ordered.pop();
 	    //cout<<"Popping Comma (PROJECTION):"<<endl;
	    temp = ordered.top();
	  }
	}
	else return false;

      }
      //cout<<"FOUND T_RPAR(Renming)"<<endl;
      ordered.pop();
      if(ordered.empty()){
	//cout<<"INVALID(Renaming): STACK EMPTY"<<endl;
	return false;
      }
      if(par_atomicexpression()){
	for (int i = 0; i < recur_depth; ++i) {
	  switch (return_types[i]) {
	  case T_PROJECT:
	    cout << "proj type" << endl;
	    break;
	  default:
	    break;
	  }
	}
	return true;
      }
      else return false;
    }
  }
  return false;
}
#include <iostream>
#include "Database.h"
#include "Parser.h"
#include "Token.h"

using namespace std;

int main() {
  // Database db;
  //db.open("animals");
  //db.show("animals");
  ifstream infile;
  string S;
  Parser dp;
  string input_file = "Input.txt";
  string output_file = "Output.txt";
  infile.open(input_file.c_str());

  // Read each line, tokenize, pass token stack to parser
  // Parser then verifies/refutes strings
  while(!infile.eof()){
    //    cout<<"Reading From File"<<endl;
    getline(infile,S);
    const char * c = S.c_str();
    YY_BUFFER_STATE bp = yy_scan_string(c);
    yy_switch_to_buffer(bp);
    yylex();

    dp.par_program(tokens,errors);
    yy_delete_buffer(bp);
    
    while(!tokens.empty()){
      tokens.pop();
    }
    dp.par_empty();
  }
  infile.close();
  //cout<<"-------------------------------------------------------------"<<endl;
  dp.print_result(output_file);

  return 0;
}


#include "Database.h"
#include <iostream>
#include <algorithm>
#include <stdio.h>
#include <stdlib.h>

using namespace std;

typedef map<string, vector<string> > table;
typedef map<string, table> table_list;

bool Database::numerical_str(string& s) {
  string::const_iterator it = s.begin();
  while (it != s.end()) {
    if (!isdigit(*it)) { return false; }
    ++it;
  }
  return true;
}

Database::Database() {
  //mat_updated = false;
}

bool Database::file_exists(string file_name) {
  ifstream ifs(file_name);
  if (ifs.good()) { return true; }
  return false;
}

// In relation 'table_name', if attribute 'lhs' exists,
// check entries 'x' satisfying x op rhs
table Database::selection(string table_name,
			  string lhs, string op, string rhs) {
  table_list::iterator it = db_copy.find(table_name);
  if (it != db_copy.end())
    {
      table t = db_copy[table_name];
      return selection(t, lhs, op, rhs);
    }
  else
    {
      throw invalid_argument("No such table open!\n");
      return table();
    }
}

// In relation 'table_name', if attribute 'lhs' exists,
// check entries 'x' satisfying x op rhs
table Database::selection(table t,
			  string lhs, string op, string rhs) {
  //table_list::iterator table_it = db_copy.find(table_name);
  table result;
  vector<string> selected;
  // add fitting selection from db_copy to result
  vector<string> v = t[lhs];
  // add the primary_key
  result[PRIMARY_KEY] = t[PRIMARY_KEY];

  for (int i = 0; i < v.size(); ++i) {
    if (op != "==") {
      if (!numerical_str(rhs)) {
	cout << "Non numerical input!" << endl;
	return result;
      }

      else {
	if ((op == "<" && stod(v[i]) < stod(rhs)) ||
	    (op == "<=" && stod(v[i]) <= stod(rhs)) ||
	    (op == ">" && stod(v[i]) > stod(rhs)) ||
	    (op == ">=" && stod(v[i]) >= stod(rhs))) {
	  for (auto it : t) {
	    if (it.first != PRIMARY_KEY)
	      {
		selected = t[it.first];
		result[it.first].push_back(selected[i]);
	      }
	  }
	}
      }
    }

    // Handles equality for both words and strings
    else if (op == "==") {
      if (v[i] == rhs) {
	for (auto it : t) {
	  if (it.first != PRIMARY_KEY)
	    {
	      selected = t[it.first];
	      result[it.first].push_back(selected[i]);
	    }
	}
      }
    }
    else if (op == "!=") {
      if (v[i] != rhs) {
	for (auto it : t) {
	  if (it.first != PRIMARY_KEY)
	    {
	      selected = t[it.first];
	      result[it.first].push_back(selected[i]);
	    }
	}
      }
    }
    else if (op == "*") {
      for (auto it : t) {
	if (it.first != PRIMARY_KEY)
	  {
	    selected = t[it.first];
	    result[it.first].push_back(selected[i]);
	  }
      }
    }
  }

  return result;
}



table Database::projection(table tbl, vector<string> attributes) {
  table result;
  table::iterator it;
  // add primary_key
  result[PRIMARY_KEY] = tbl[PRIMARY_KEY];
  for (int i = 0; i < attributes.size(); ++i)
    {	// find the columns to get
      it = tbl.find(attributes[i]);
      if (it != tbl.end())
	{	// grab the values
	  result[attributes[i]] = tbl[attributes[i]];
	}
    }
  return result;
}

table Database::projection(string tbl_name, vector<string> attributes)
{
  table_list::iterator it = db_copy.find(tbl_name);
  if (it != db_copy.end())
    {
      return projection(it->second, attributes);
    }
  else
    {
      throw invalid_argument("Table " + tbl_name + " not found!");
      return table();
    }
}

table Database::renaming(table tbl, vector<string> old_attr, vector<string> new_attr) {
  table new_table;

  table::iterator it = tbl.begin();
  while (it != tbl.end())
    {
      vector<string>::iterator vec_it = find(old_attr.begin(), old_attr.end(), it->first);
      if (vec_it != old_attr.end())
	{
			
	  int index = vec_it - old_attr.begin();
	  // Do not rename primary_key column
	  if(old_attr[index] != PRIMARY_KEY) new_table[new_attr[index]] = it->second;
	}
      else
	{
	  new_table[it->first] = it->second;
	}
      ++it;
    }

  return new_table;
}

table Database::renaming(string tbl_name, vector<string> old_attr, vector<string> new_attr) {
  if (db_copy.count(tbl_name) > 0)
    {
      return renaming(db_copy[tbl_name], old_attr, new_attr);
    }
  else
    {
      throw invalid_argument("Table " + tbl_name + " not found!");
      return table();
    }
}

table Database::set_union(table tbl1, table tbl2) {
  // check if tables exist in the database
  table result;
  table::iterator it1 = tbl1.begin();
  table::iterator it2 = tbl2.begin();

  // check if the two tables have the same columns
  bool same_attributes = true;
  for (it1; it1 != tbl1.end(); ++it1)
    {
      same_attributes = (it1->first != it2->first) ? false : true;
      ++it2;
    }
  if (same_attributes)
    {
      it1 = tbl1.begin();
      it2 = tbl2.begin();
      // insert tuples from first table
      for (it1; it1 != tbl1.end(); ++it1)
	{
	  result[it1->first] = it1->second;
	}
      // insert tuples from second table and check if duplicates exist
      table::iterator r_it = result.begin();
      bool duplicate_tuple = true;
      bool duplicate_primary_key = true;
      for (int i = 0; i < it2->second.size(); ++i)
	{	// start comparing the values of the first attribute in result
	  for (int j = 0; j < r_it->second.size(); ++j)
	    {	// to the values of the first attribute of table_2
	      // check if the tuple is a duplicate
	      if (duplicate_tuple)
		{
		  for (r_it; r_it != result.end(); ++r_it)
		    {	// iterate through all the columns and compare
		      // the values of the tuples
		      if (r_it != result.end() || it2 != tbl2.end())
			{
			  if (duplicate_tuple)
			    {
			      if (it2->second[i] != r_it->second[j])
				{
				  if (r_it->first == PRIMARY_KEY) duplicate_primary_key = false;
				  duplicate_tuple = false;
				}
			    }
			  else break;
			}
		      else break;
		      ++it2;
		    }
		  r_it = result.begin();
		  it2 = tbl2.begin();
		}
	      else break;
	    }

	  if (!duplicate_tuple && !duplicate_primary_key)
	    {	// add the row from table_2 to result if not a duplicate
	      for (r_it; r_it != result.end(); ++r_it)
		{	// iterate through all the columns and add 
		  // the value of the correct row
		  r_it->second.push_back(it2->second[i]);
		  ++it2;
		}
	      // reset variables
	      r_it = result.begin();
	      it2 = tbl2.begin();
	      duplicate_tuple = true;
	    }
	}
    }

  return result;
}

table Database::set_union(string tbl_name1, string tbl_name2)
{
  table_list::iterator it1 = db_copy.find(tbl_name1);
  table_list::iterator it2 = db_copy.find(tbl_name2);
  //table::iterator p_key = primary_keys.find(tbl_name1);
  if (it1 != db_copy.end())
    {
      if (it2 != db_copy.end())
	{
	  return set_union(it1->second, it2->second);
	}
      else
	{
	  throw invalid_argument("Table " + tbl_name1 + " not found!");
	}
    }
  else
    {
      throw invalid_argument("Table " + tbl_name1 + " not found!");
      return table();
    }
}

// A \ B = {a in A | a not in B}
table Database::set_diff(string table_name_1, string table_name_2) {
  table result;

  // check if tables exist in the database
  if (db_copy.count(table_name_1) > 0 && db_copy.count(table_name_2) > 0) {
    table table_1 = db_copy[table_name_1];
    table table_2 = db_copy[table_name_2];

    vector<string> t2_data;
    // For each attribute check if corresponding vector in tb1 is not in tb2
    // If, so add that attribute and its vector into result
    for (auto& it1 : table_1) {
      // Case where attributes match

      if (table_2.count(it1.first) > 0) {
	for (int i = 0; i < it1.second.size(); ++i) {
	  t2_data = table_2[it1.first];

	  // If elem not in attr vector 2, but in attr vector 1, put in result 
	  if (find(t2_data.begin(), t2_data.end(), it1.second[i])
	      == t2_data.end()) {
	    result[it1.first].push_back(it1.second[i]);
	  }
	}
      }

      // Case where attributes do not mach
      else {
	result[it1.first] = it1.second;
      }
    }
    // Add primary key
    result[PRIMARY_KEY] = table_1[PRIMARY_KEY];
  }
  return result;
}


// A \ B = {a in A | a not in b}
table Database::set_diff(table table_1, table table_2) {
  table result;

  vector<string> t2_data;

  // For each attribute check if corresponding vector in tb1 is not in tb2
  // If, so add that attribute and its vector into result
  for (auto& it1 : table_1) {
    // Case where attributes match

    if (table_2.count(it1.first) > 0) {
      for (int i = 0; i < it1.second.size(); ++i) {
	t2_data = table_2[it1.first];

	// If elem not in attr vector 2, but in attr vector 1, put in result 
	if (find(t2_data.begin(), t2_data.end(), it1.second[i])
	    == t2_data.end()) {
	  result[it1.first].push_back(it1.second[i]);
	}
      }
    }
    // Case where attributes do not mach
    else {
      result[it1.first] = it1.second;
    }
  }
  // Add primary key
  result[PRIMARY_KEY] = table_1[PRIMARY_KEY];
  return result;
}

table Database::cross_product(table tbl1, table tbl2) {
  // check if tables exist in the database
  table result;
  table::iterator it1 = tbl1.begin();
  table::iterator it2 = tbl2.begin();
  // add the attributes to the resulting table, even if they are duplicates
  for (it1; it1 != tbl1.end(); ++it1)
    {
      if (it1->first != PRIMARY_KEY) result[it1->first];
    }
  for (it2; it2 != tbl2.end(); ++it2)
    {	// check if there are duplicate attributes present
      if(it2->first == PRIMARY_KEY) ++it2;
      table::iterator dup = result.find(it2->first);
      if (dup == result.end())
	{
	  result[it2->first];
	}
      else
	{
	  char suffix = '1';
	  string dup_attribute_name = it2->first;
	  dup_attribute_name += suffix;
	  while (result.find(dup_attribute_name) != result.end())
	    {
	      dup_attribute_name = it2->first;
	      suffix += 1;
	    }
	  result[dup_attribute_name];
	}
    }
  // add the values to the attibutes
  table::iterator r_it = result.begin();
  it1 = tbl1.begin();
  it2 = tbl2.begin();
  if (it1->first == PRIMARY_KEY) ++it1;
  if (it2->first == PRIMARY_KEY) ++it2;
  for (int i = 0; i < it1->second.size(); ++i)
    {
      for (int j = 0; j < it2->second.size(); ++j)
	{
	  for (it1; it1 != tbl1.end(); ++it1)
	    {
	      if (it1->first != PRIMARY_KEY) r_it->second.push_back(it1->second[i]);
	      else ++it1;
	      ++r_it;
	    }
	  for (it2; it2 != tbl2.end(); ++it2)
	    {
	      if (it2->first != PRIMARY_KEY) r_it->second.push_back(it2->second[j]);
	      else ++it2;
	      ++r_it;
	    }
	  // reset iterators
	  it1 = tbl1.begin();
	  it2 = tbl2.begin();
	  if (it1->first == PRIMARY_KEY) ++it1;
	  if (it2->first == PRIMARY_KEY) ++it2;
	  r_it = result.begin();
	}
    }
  // add the primary key from table 1
  result[PRIMARY_KEY] = tbl1[PRIMARY_KEY];
  return result;
}

table Database::cross_product(string tbl_name1, string tbl_name2)
{
  table_list::iterator it1 = db_copy.find(tbl_name1);
  table_list::iterator it2 = db_copy.find(tbl_name2);
  if (it1 != db_copy.end())
    {
      if (it2 != db_copy.end())
	{
	  return cross_product(it1->second, it2->second);
	}
      else
	{
	  throw invalid_argument("Table " + tbl_name2 + " not found!");
	}
    }
  else
    {
      throw invalid_argument("Table " + tbl_name1 + " not found!");
      return table();
    }
}

void Database::open(string table_name) {
  update_mat(table_name);
}

//Removes a table from db_copy                                    
void Database::close(string table_name) {
  if (db_copy.count(table_name) > 0) {
    db_copy.erase(table_name);
  }
}


/* This performs the same function as close
   void Database::delete_table(string table_name) {
   table_list::iterator it;
   it = db_copy.find(table_name);
   if (it != db_copy.end())
   {
   db_copy.erase(it);
   }
   }*/

void Database::save(table t, string table_name) {
  if (file_exists(table_name)) { return; } // Throw exp

  fstream fs(table_name, fstream::in | fstream::out | fstream::trunc);
  // find primary key
  table::iterator key_it = t.find(PRIMARY_KEY);
  // write table_name minus ".db"
  // write table contents
  fs << table_name.substr(0, table_name.size() - 3) << ' ' << endl;
  for (auto it1 : t) {
    if (key_it->second[0] == it1.first) {
      // add the primary key to the file
      fs << "$        ";// << key_it->second[0] << endl;
      for (int i = 0; i < t["$primary_key"].size(); ++i) {
	fs << t["$primary_key"][i] << ' ';
      }
      fs << endl;
    }
    else {
      // add the attribute and its members to the file
      fs << "*        " << it1.first << ' ';
      for (auto it2 : t[it1.first]) {
	fs << it2 << ' ';
      }
      fs << endl;
    }
  }
  cout << "Done" << endl;
  fs.close();
}


// Halt execution
void Database::exit() {
  abort();
}

void Database::show(table t) {
  for (auto it1 : t) {
    cout << it1.first << " - ";
    for (auto it2 : t[it1.first]) {
      cout << it2 << ' ';
    }
    cout << endl;
  }
  cout << endl;
}

void Database::show(string tbl_name)
{
  table_list::iterator it = db_copy.find(tbl_name);
  if (it != db_copy.end())
    {
      show(it->second);
    }
  else
    {
      cerr << "The table does not exist!\n";
    }
}

table Database::update(table tbl, string cond_attr, string op, string cond_val, vector<string> attr_list, vector<string> val_list)
{
  // deletes the row specified by the condition
  table::iterator it = tbl.find(cond_attr);
  vector<int> row_numbers;
  // return the same table if primary key is going to be modified
  vector<string>::iterator v_it = find(attr_list.begin(), attr_list.end(), tbl[PRIMARY_KEY][0]);
  if (v_it != attr_list.end())
    {	// if the primary key is in the list of attributes to modify
      // check if the value that corresponds already exists
      int list_index = v_it - attr_list.begin();			// find the index that corresponds
      vector<string> key_values = tbl[tbl[PRIMARY_KEY][0]];
      key_values.push_back(val_list[list_index]);			// insert value to modify
      // check if the column is still unique if the value is inserted
      sort(key_values.begin(), key_values.end());
      if (unique(key_values.begin(), key_values.end()) != key_values.end())
	{	// duplicate primary key is trying to be put into the table
	  cerr << "The value " << val_list[list_index] << " already exists for key attribute " << attr_list[list_index] << ".\n";
	  cerr << "The table will not be modified.\n";
	}
    }
  // check the condition and select the appropriate comparison
  if (op == "==")
    {
      for (int i = 0; i < it->second.size(); ++i)
	{	// figure out the index of the rows to update
	  if (it->second[i] == cond_val) row_numbers.push_back(i);
	}
    }
  else if (op == "!=")
    {
      for (int i = 0; i < it->second.size(); ++i)
	{	// figure out the index of the rows to update
	  if (it->second[i] != cond_val) row_numbers.push_back(i);
	}
    }
  else if (op == "<")
    {
      for (int i = 0; i < it->second.size(); ++i)
	{	// figure out the index of the rows to update
	  if (numerical_str(cond_val) && numerical_str(it->second[i]))
	    {
	      if (stod(it->second[i]) < stod(cond_val)) row_numbers.insert(row_numbers.begin(), i);
	    }
	  else if (it->second[i] < cond_val) row_numbers.push_back(i);
	}
    }
  else if (op == ">")
    {
      for (int i = 0; i < it->second.size(); ++i)
	{	// figure out the index of the rows to update
	  if (numerical_str(cond_val) && numerical_str(it->second[i]))
	    {
	      if (stod(it->second[i]) > stod(cond_val)) row_numbers.insert(row_numbers.begin(), i);
	    }
	  else if (it->second[i] > cond_val) row_numbers.push_back(i);
	}
    }
  else if (op == "<=")
    {
      for (int i = 0; i < it->second.size(); ++i)
	{	// figure out the index of the rows to update
	  if (numerical_str(cond_val) && numerical_str(it->second[i]))
	    {
	      if (stod(it->second[i]) <= stod(cond_val)) row_numbers.insert(row_numbers.begin(), i);
	    }
	  else if (it->second[i] <= cond_val) row_numbers.push_back(i);
	}
    }
  else if (op == ">=")
    {
      for (int i = 0; i < it->second.size(); ++i)
	{	// figure out the index of the rows to update
	  if (numerical_str(cond_val) && numerical_str(it->second[i]))
	    {
	      if (stod(it->second[i]) >= stod(cond_val)) row_numbers.insert(row_numbers.begin(), i);
	    }
	  else if (it->second[i] >= cond_val) row_numbers.push_back(i);
	}
    }
  if (!row_numbers.empty())
    {	// if row_numbers is empty, the rows were not found
      for (int i = 0; i < attr_list.size(); ++i)
	{	// find the attribute in the table from the 
	  // attribute list
	  it = tbl.find(attr_list[i]);
	  for (int j = 0; j < row_numbers.size(); ++j)
	    {	// go through the row numbers to modify
	      // and modify it with the corresponding value
	      it->second[row_numbers[j]] = val_list[i];
	    }
	}

    }
  return tbl;
}

table Database::update(string tbl_name, string cond_attr, string op, string cond_val, vector<string> attr_list, vector<string> val_list)
{
  table_list::iterator it = db_copy.find(tbl_name);
  if (it != db_copy.end())
    {
      return update(it->second, cond_attr, op, cond_val, attr_list, val_list);
    }
  else
    {
      throw invalid_argument("Table " + tbl_name + " not found!");
      return db_copy.end()->second;
    }
}

table Database::create(vector<string> attributes, vector<string> prim_keys) {
  // create a new table with the specified attributes
  // insert_tuple should be used to insert data
  table new_table;
  new_table[PRIMARY_KEY] = prim_keys;//vector<string>(1, prim_keys);
  //new_table[primary_key];		// insert primary key if not specified in attributes vector
  for (int i = 0; i < attributes.size(); ++i)
    {
      new_table[attributes[i]];
    }
  return new_table;
}

table Database::insert_tuple(table dest_tbl, table tuples) {
  // inserts the tuples into the destination table
  table::iterator dest_it = dest_tbl.begin();
  table::iterator tup_it = tuples.begin();
  bool attributes_match = true;
  while (dest_it != dest_tbl.end() || tup_it != tuples.end())
    {	// check if the destination table and the tuples to insert
      // have the same attributes
      if (dest_it->first == PRIMARY_KEY) ++dest_it;
      if (dest_it->first != tup_it->first)
	{
	  attributes_match = false;
	  break;
	}
      ++dest_it;
      ++tup_it;
    }
  if (attributes_match)
    {	// check if a duplicate primary key will be inserted
      dest_it = dest_tbl.find(dest_tbl[PRIMARY_KEY][0]);
      tup_it = tuples.find(dest_tbl[PRIMARY_KEY][0]);
      vector<string> key_insertions = dest_it->second;
      key_insertions.insert(key_insertions.end(), tup_it->second.begin(), tup_it->second.end());
      sort(key_insertions.begin(), key_insertions.end());
      if (unique(key_insertions.begin(), key_insertions.end()) == key_insertions.end())
	{	// if the keys that are inserted are unique and
	  // if the attributes match, insert the tuples
	  dest_it = dest_tbl.begin();
	  tup_it = tuples.begin();
	  while (dest_it != dest_tbl.end() || tup_it != tuples.end())
	    {
	      if (dest_it->first == PRIMARY_KEY) ++dest_it;
	      for (int i = 0; i < tup_it->second.size(); ++i)
		{	// insert the tuple into the table
		  // but don't insert into primary_key column
		  dest_it->second.push_back(tup_it->second[i]);
		}
	      ++dest_it;
	      ++tup_it;
	    }
	}
    }
  return dest_tbl;
}

table Database::insert_tuple(string dest_tbl, table tuples)
{
  table_list::iterator it = db_copy.find(dest_tbl);
  if (it != db_copy.end())
    {
      return insert_tuple(it->second, tuples);
    }
  else
    {
      throw invalid_argument("Table " + dest_tbl + " not found!");
      return db_copy.end()->second;
    }
}

table Database::delete_tuple(table tbl, string cond_attr, string op, string cond_val) {
  // deletes the row specified by an attribute and a 
  if (cond_attr == PRIMARY_KEY) return tbl;		// do nothing if asked to delete the primary_key
  table::iterator it = tbl.find(cond_attr);
  vector<int> row_numbers;
  // check the condition and select the appropriate comparison
  if (op == "==")
    {
      for (int i = 0; i < it->second.size(); ++i)
	{	// figure out the index of the row to delete
	  if (it->second[i] == cond_val) row_numbers.insert(row_numbers.begin(), i);
	}
    }
  else if (op == "!=")
    {
      for (int i = 0; i < it->second.size(); ++i)
	{	// figure out the index of the row to delete
	  if (it->second[i] != cond_val) row_numbers.insert(row_numbers.begin(), i);
	}
    }
  else if (op == "<")
    {
      for (int i = 0; i < it->second.size(); ++i)
	{	// figure out the index of the row to delete
	  if (numerical_str(cond_val) && numerical_str(it->second[i]))
	    {
	      if (stod(it->second[i]) < stod(cond_val)) row_numbers.insert(row_numbers.begin(), i);
	    }
	  else if (it->second[i] < cond_val) row_numbers.insert(row_numbers.begin(), i);
	}
    }
  else if (op == ">")
    {
      for (int i = 0; i < it->second.size(); ++i)
	{	// figure out the index of the row to delete
	  if (numerical_str(cond_val) && numerical_str(it->second[i]))
	    {
	      if (stod(it->second[i]) > stod(cond_val)) row_numbers.insert(row_numbers.begin(), i);
	    }
	  else if (it->second[i] > cond_val) row_numbers.insert(row_numbers.begin(), i);
	}
    }
  else if (op == "<=")
    {
      for (int i = 0; i < it->second.size(); ++i)
	{	// figure out the index of the row to delete
	  if (numerical_str(cond_val) && numerical_str(it->second[i]))
	    {
	      if (stod(it->second[i]) <= stod(cond_val)) row_numbers.insert(row_numbers.begin(), i);
	    }
	  else if (it->second[i] <= cond_val) row_numbers.insert(row_numbers.begin(), i);
	}
    }
  else if (op == ">=")
    {
      for (int i = 0; i < it->second.size(); ++i)
	{	// figure out the index of the row to delete
	  if (numerical_str(cond_val) && numerical_str(it->second[i]))
	    {
	      if (stod(it->second[i]) >= stod(cond_val)) row_numbers.insert(row_numbers.begin(), i);
	    }
	  else if (it->second[i] >= cond_val) row_numbers.insert(row_numbers.begin(), i);
	}
    }
  // delete the rows that matched, if any
  if (!row_numbers.empty())
    {	// if row_numbers is empty, the rows were not found
      it = tbl.begin();
      while (it != tbl.end())
	{	// iterate through and erase the tuple
	  if (it->first != PRIMARY_KEY)
	    {
	      for (int i = 0; i < row_numbers.size(); ++i)
		{
		  it->second.erase(it->second.begin() + row_numbers[i]);
		}
	    }
	  ++it;
	}
    }
  return tbl;
}

table Database::delete_tuple(string tbl_name, string cond_attr, string op, string cond_val)
{
  table_list::iterator it = db_copy.find(tbl_name);
  if (it != db_copy.end())
    {
      return delete_tuple(it->second, cond_attr, op, cond_val);
    }
  else
    {
      throw invalid_argument("Table " + tbl_name + " not found!");
      return db_copy.end()->second;
    }
}

// Add a table from a db file to map structure
void Database::update_mat(string table_name) {
  // No trying to re-use table names
  if (db_copy.count(table_name) > 0)
    {
      throw invalid_argument("Table name exists already!");
    }

  string line, tok, new_name, attr_name, primary_key;
  string delim = " ";
  vector<string> temp;
  table new_table;
  size_t pos = 0;

  fstream fs(table_name + ".db");
  if (fs.is_open())
    {
      // Tokenize 
      while (getline(fs, line)) {
	while ((pos = line.find(delim)) != string::npos) {
	  tok = line.substr(0, pos);
	  temp.push_back(tok);
	  line.erase(0, pos + delim.length());
	}

	// Grab table name if nontrivial line did not start with * or $. 
	// Grab table attribute name otherwise
	if (temp.size() != 0) {
	  if (temp[0] != "*" && temp[0] != "$") {
	    new_name = temp[0];
	  }

	  // Get table attribute name, put following data into vector
	  else if (temp[0] == "*") {
	    vector<string>::const_iterator beg = temp.begin() + 1;
	    vector<string>::const_iterator end = temp.end();
	    vector<string> data(beg, end);

	    // Remove whitespace entries
	    /*for (int i = 0; i < data.size(); ++i) {
	      if (data[i].size() == 0) {
	      data.erase(data.begin() + i);
	      }
	      }*/

	    /*for (int i = 0; i < data.size(); ++i) {
	      if (data[i].size() != 0) {
	      attr_name = data[i];
	      data.erase(data.begin() + i);
	      break;
	      }
	      }*/
	    attr_name = data[0];
	    data.erase(data.begin());
	    // db_copy[new_name][attr_name] = data; // Add entry to db
	    new_table[attr_name] = data;
	  }

	  // Get the primary key, put into table under PRIMARY_KEY attribute
	  else if (temp[0] == "$") {
	    vector<string>::const_iterator beg = temp.begin() + 1;
	    vector<string>::const_iterator end = temp.end();
	    vector<string> data(beg, end);

	    // Remove whitespace entries
	    /*for (int i = 0; i < data.size(); ++i) {
	      if (data[i].size() == 0) {
	      data.erase(data.begin() + i);
	      }
	      }*/

	    /*for (int i = 0; i < data.size(); ++i) {
	      if (data[i].size() != 0) {
	      attr_name = data[i];
	      primary_key = data[i];
	      data.erase(data.begin() + i);
	      break;
	      }
	      }*/
	    attr_name = data[0];
	    primary_key = data[0];
	    data.erase(data.begin());
	    //db_copy[new_name][PRIMARY_KEY] = vector<string> (1, primary_key);	// Add primary key to db
	    //db_copy[new_name][attr_name] = data; // Add entry to db
	    new_table[PRIMARY_KEY] = vector<string>(1, primary_key);
	    new_table[attr_name] = data;

	    // check for duplicate primary keys
	    sort(data.begin(), data.end());
	    if (unique(data.begin(), data.end()) != data.end())
	      {	// do not insert table because primary keys are not unique
		cerr << "The table " << table_name << " could not be inserted because the\nprimary keys are not unique.\n";
		fs.close();
		return;
	      }
	  }
	}
	temp = {};
      }

      // insert into table list
      db_copy[new_name] = new_table;
      mat_updated = true;
      fs.close();
    }
  else
    {
      cerr << "Error opening file " << table_name << ".db\n";
    }
}

void Database::print_db() {
  //if (!mat_updated) {update_mat();}

  for (auto it1 : db_copy) {
    cout << it1.first << " - ";
    map<string, vector<string> > &inner1 = it1.second;
    cout << inner1.size() << endl;
    for (auto it2 : inner1) {
      cout << it2.first << ": ";
      vector<string> &innermost = it2.second;
      for (auto it3 : innermost) {
	cout << it3 << ' ';
      }
      cout << endl;
    }
    cout << endl;
  }
  cout << endl;
}

table_list Database::return_DB() {
  return db_copy;
}

